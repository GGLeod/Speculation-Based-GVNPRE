../test/Treesort.c:130:3: warning: add explicit braces to avoid dangling else [-Wdangling-else]
                else Insert(n,t->right);
                ^
../test/Treesort.c:138:5: warning: add explicit braces to avoid dangling else [-Wdangling-else]
           else result = Checktree(p->left) && result;
           ^
../test/Treesort.c:141:5: warning: add explicit braces to avoid dangling else [-Wdangling-else]
           else result = Checktree(p->right) && result;
           ^
3 warnings generated.
Writing '.Initrand.dot'...
Writing '.Rand.dot'...
Writing '.tInitarr.dot'...
Writing '.CreateNode.dot'...
Writing '.Insert.dot'...
Writing '.Checktree.dot'...
Writing '.Trees.dot'...
Writing '.main.dot'...
Error: dot: can't open .Treesort.dot
begin
changed
entry
avaiableOut for each Basic Block 
Block: entry
1   store i64 74755, i64* @seed, align 8
anticipateIn for each Basic Block 
Block: entry
2
available out point of each value number0: 
1: entry 
antipate in point of each value number0: 
1: 
valunumber: 0
0				0				
0				0				
min cut from 0 to 1
valunumber: 1
0				0				
0				0				
min cut from 0 to 1
revNewValue
rename: entry
  store i64 74755, i64* @seed, align 8
  ret void
fill in phi

entry:
  store i64 74755, i64* @seed, align 8
  ret void

entry
  store i64 74755, i64* @seed, align 8
  ret void
begin
changed
entry
new
  %0 = load i64, i64* @seed, align 8
  %1 = load i64, i64* @seed, align 8
changed
entry
  %0 = load i64, i64* @seed, align 8
  %1 = load i64, i64* @seed, align 8
avaiableOut for each Basic Block 
Block: entry
1   %0 = load i64, i64* @seed, align 8
3   %mul = mul nsw i64 %0, 1309
5   %add = add nsw i64 %mul, 13849
7   %and = and i64 %add, 65535
8   store i64 %and, i64* @seed, align 8
9   %1 = load i64, i64* @seed, align 8
10   %conv = trunc i64 %1 to i32
anticipateIn for each Basic Block 
Block: entry
1   %0 = load i64, i64* @seed, align 8
9   %1 = load i64, i64* @seed, align 8
11
available out point of each value number0: 
1: entry 
2: 
3: entry 
4: 
5: entry 
6: 
7: entry 
8: entry 
9: entry 
10: entry 
antipate in point of each value number0: 
1: entry 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: entry 
10: 
valunumber: 0
0				0				
0				0				
min cut from 0 to 1
valunumber: 1
0				0				
0				0				
min cut from 0 to 1
valunumber: 2
0				0				
0				0				
min cut from 0 to 1
valunumber: 3
0				0				
0				0				
min cut from 0 to 1
valunumber: 4
0				0				
0				0				
min cut from 0 to 1
valunumber: 5
0				0				
0				0				
min cut from 0 to 1
valunumber: 6
0				0				
0				0				
min cut from 0 to 1
valunumber: 7
0				0				
0				0				
min cut from 0 to 1
valunumber: 8
0				0				
0				0				
min cut from 0 to 1
valunumber: 9
0				0				
0				0				
min cut from 0 to 1
valunumber: 10
0				0				
0				0				
min cut from 0 to 1
revNewValue
rename: entry
  %0 = load i64, i64* @seed, align 8
  %mul = mul nsw i64 %0, 1309
  %0 = load i64, i64* @seed, align 8
  %add = add nsw i64 %mul, 13849
  %mul = mul nsw i64 %0, 1309
  %and = and i64 %add, 65535
  %add = add nsw i64 %mul, 13849
  store i64 %and, i64* @seed, align 8
  %and = and i64 %add, 65535
  %1 = load i64, i64* @seed, align 8
  %conv = trunc i64 %1 to i32
  %1 = load i64, i64* @seed, align 8
  ret i32 %conv
  %conv = trunc i64 %1 to i32
fill in phi

entry:
  %0 = load i64, i64* @seed, align 8
  %mul = mul nsw i64 %0, 1309
  %add = add nsw i64 %mul, 13849
  %and = and i64 %add, 65535
  store i64 %and, i64* @seed, align 8
  %1 = load i64, i64* @seed, align 8
  %conv = trunc i64 %1 to i32
  ret i32 %conv

entry
  %0 = load i64, i64* @seed, align 8
  %mul = mul nsw i64 %0, 1309
  %add = add nsw i64 %mul, 13849
  %and = and i64 %add, 65535
  store i64 %and, i64* @seed, align 8
  %1 = load i64, i64* @seed, align 8
  %conv = trunc i64 %1 to i32
  ret i32 %conv
begin
changed
for.inc
if.end16
if.then
if.end
if.then13
if.else.if.end_crit_edge
if.else
new
  %i.0 = phi i32 [ 1, %entry ], [ %inc, %for.inc ]
  %idxprom9 = sext i32 %i.0 to i64
  %4 = load i32, i32* @littlest, align 4
for.body
new
  %call = call i32 @Rand()
  %idxprom9 = sext i32 %i.0 to i64
  %i.0 = phi i32 [ 1, %entry ], [ %inc, %for.inc ]
  %1 = load i32, i32* @biggest, align 4
  %4 = load i32, i32* @littlest, align 4
for.end
for.cond
new
  %call = call i32 @Rand()
  %i.0 = phi i32 [ 1, %entry ], [ %inc, %for.inc ]
  %1 = load i32, i32* @biggest, align 4
  %4 = load i32, i32* @littlest, align 4
entry
new
  %call = call i32 @Rand()
i32 1
  %1 = load i32, i32* @biggest, align 4
  %4 = load i32, i32* @littlest, align 4
changed
for.inc
new
  %call = call i32 @Rand()
  %inc = add nsw i32 %i.0, 1
  %1 = load i32, i32* @biggest, align 4
  %4 = load i32, i32* @littlest, align 4
if.end16
new
  %call = call i32 @Rand()
  %inc = add nsw i32 %i.0, 1
  %1 = load i32, i32* @biggest, align 4
  %4 = load i32, i32* @littlest, align 4
if.then
new
  %call = call i32 @Rand()
  %inc = add nsw i32 %i.0, 1
  %1 = load i32, i32* @biggest, align 4
  %4 = load i32, i32* @littlest, align 4
  %i.0 = phi i32 [ 1, %entry ], [ %inc, %for.inc ]
  %idxprom7 = sext i32 %i.0 to i64
if.end
new
  %call = call i32 @Rand()
  %inc = add nsw i32 %i.0, 1
  %1 = load i32, i32* @biggest, align 4
  %4 = load i32, i32* @littlest, align 4
if.then13
new
  %call = call i32 @Rand()
  %inc = add nsw i32 %i.0, 1
  %1 = load i32, i32* @biggest, align 4
  %4 = load i32, i32* @littlest, align 4
  %i.0 = phi i32 [ 1, %entry ], [ %inc, %for.inc ]
  %idxprom14 = sext i32 %i.0 to i64
if.else.if.end_crit_edge
new
  %call = call i32 @Rand()
  %inc = add nsw i32 %i.0, 1
  %1 = load i32, i32* @biggest, align 4
  %4 = load i32, i32* @littlest, align 4
if.else
  %i.0 = phi i32 [ 1, %entry ], [ %inc, %for.inc ]
  %idxprom9 = sext i32 %i.0 to i64
  %4 = load i32, i32* @littlest, align 4
new
  %inc = add nsw i32 %i.0, 1
  %call = call i32 @Rand()
  %i.0 = phi i32 [ 1, %entry ], [ %inc, %for.inc ]
  %idxprom14 = sext i32 %i.0 to i64
  %1 = load i32, i32* @biggest, align 4
  %4 = load i32, i32* @littlest, align 4
for.body
  %call = call i32 @Rand()
  %idxprom9 = sext i32 %i.0 to i64
  %i.0 = phi i32 [ 1, %entry ], [ %inc, %for.inc ]
  %1 = load i32, i32* @biggest, align 4
  %4 = load i32, i32* @littlest, align 4
new
  %inc = add nsw i32 %i.0, 1
  %i.0 = phi i32 [ 1, %entry ], [ %inc, %for.inc ]
  %call = call i32 @Rand()
  %idxprom7 = sext i32 %i.0 to i64
  %4 = load i32, i32* @littlest, align 4
  %idxprom14 = sext i32 %i.0 to i64
  %1 = load i32, i32* @biggest, align 4
for.cond
  %call = call i32 @Rand()
  %i.0 = phi i32 [ 1, %entry ], [ %inc, %for.inc ]
  %1 = load i32, i32* @biggest, align 4
  %4 = load i32, i32* @littlest, align 4
entry
  %call = call i32 @Rand()
i32 1
  %1 = load i32, i32* @biggest, align 4
  %4 = load i32, i32* @littlest, align 4
changed
for.inc
  %call = call i32 @Rand()
  %inc = add nsw i32 %i.0, 1
  %1 = load i32, i32* @biggest, align 4
  %4 = load i32, i32* @littlest, align 4
if.end16
  %call = call i32 @Rand()
  %inc = add nsw i32 %i.0, 1
  %1 = load i32, i32* @biggest, align 4
  %4 = load i32, i32* @littlest, align 4
if.then
  %call = call i32 @Rand()
  %inc = add nsw i32 %i.0, 1
  %1 = load i32, i32* @biggest, align 4
  %4 = load i32, i32* @littlest, align 4
  %i.0 = phi i32 [ 1, %entry ], [ %inc, %for.inc ]
  %idxprom7 = sext i32 %i.0 to i64
if.end
  %call = call i32 @Rand()
  %inc = add nsw i32 %i.0, 1
  %1 = load i32, i32* @biggest, align 4
  %4 = load i32, i32* @littlest, align 4
if.then13
  %call = call i32 @Rand()
  %inc = add nsw i32 %i.0, 1
  %1 = load i32, i32* @biggest, align 4
  %4 = load i32, i32* @littlest, align 4
  %i.0 = phi i32 [ 1, %entry ], [ %inc, %for.inc ]
  %idxprom14 = sext i32 %i.0 to i64
if.else.if.end_crit_edge
  %call = call i32 @Rand()
  %inc = add nsw i32 %i.0, 1
  %1 = load i32, i32* @biggest, align 4
  %4 = load i32, i32* @littlest, align 4
if.else
  %inc = add nsw i32 %i.0, 1
  %call = call i32 @Rand()
  %i.0 = phi i32 [ 1, %entry ], [ %inc, %for.inc ]
  %idxprom14 = sext i32 %i.0 to i64
  %1 = load i32, i32* @biggest, align 4
  %4 = load i32, i32* @littlest, align 4
for.body
  %inc = add nsw i32 %i.0, 1
  %i.0 = phi i32 [ 1, %entry ], [ %inc, %for.inc ]
  %call = call i32 @Rand()
  %idxprom7 = sext i32 %i.0 to i64
  %4 = load i32, i32* @littlest, align 4
  %idxprom14 = sext i32 %i.0 to i64
  %1 = load i32, i32* @biggest, align 4
avaiableOut for each Basic Block 
Block: if.else.if.end_crit_edge
7   %call = call i32 @Rand()
15   %conv2 = trunc i64 %sub1 to i32
6   %cmp = icmp sle i32 %i.0, 5000
14   %sub1 = sub nsw i64 %sub, 50000
12   %sub = sub nsw i64 %conv, %mul
8   %conv = sext i32 %call to i64
11   %mul = mul nsw i64 %div, 100000
19   %arrayidx = getelementptr inbounds [5001 x i32], [5001 x i32]* @sortlist, i64 0, i64 %idxprom
10   %div = sdiv i64 %conv, 100000
4   %i.0 = phi i32 [ 1, %entry ], [ %inc, %for.inc ]
21   %0 = load i32, i32* %arrayidx4, align 4
22   %1 = load i32, i32* @biggest, align 4
23   %cmp5 = icmp sgt i32 %0, %1
28   %3 = load i32, i32* %arrayidx10, align 4
16   %idxprom = sext i32 %i.0 to i64
3   store i32 0, i32* @littlest, align 4
29   %4 = load i32, i32* @littlest, align 4
20   store i32 %conv2, i32* %arrayidx, align 4
2   store i32 0, i32* @biggest, align 4
30   %cmp11 = icmp slt i32 %3, %4
1   call void @Initrand()
Block: for.end
1   call void @Initrand()
2   store i32 0, i32* @biggest, align 4
3   store i32 0, i32* @littlest, align 4
4   %i.0 = phi i32 [ 1, %entry ], [ %inc, %for.inc ]
6   %cmp = icmp sle i32 %i.0, 5000
Block: for.inc
27   %inc = add nsw i32 %i.0, 1
7   %call = call i32 @Rand()
15   %conv2 = trunc i64 %sub1 to i32
6   %cmp = icmp sle i32 %i.0, 5000
14   %sub1 = sub nsw i64 %sub, 50000
12   %sub = sub nsw i64 %conv, %mul
8   %conv = sext i32 %call to i64
11   %mul = mul nsw i64 %div, 100000
19   %arrayidx = getelementptr inbounds [5001 x i32], [5001 x i32]* @sortlist, i64 0, i64 %idxprom
10   %div = sdiv i64 %conv, 100000
4   %i.0 = phi i32 [ 1, %entry ], [ %inc, %for.inc ]
21   %0 = load i32, i32* %arrayidx4, align 4
22   %1 = load i32, i32* @biggest, align 4
23   %cmp5 = icmp sgt i32 %0, %1
16   %idxprom = sext i32 %i.0 to i64
3   store i32 0, i32* @littlest, align 4
20   store i32 %conv2, i32* %arrayidx, align 4
2   store i32 0, i32* @biggest, align 4
1   call void @Initrand()
Block: if.end16
7   %call = call i32 @Rand()
15   %conv2 = trunc i64 %sub1 to i32
6   %cmp = icmp sle i32 %i.0, 5000
14   %sub1 = sub nsw i64 %sub, 50000
12   %sub = sub nsw i64 %conv, %mul
8   %conv = sext i32 %call to i64
11   %mul = mul nsw i64 %div, 100000
19   %arrayidx = getelementptr inbounds [5001 x i32], [5001 x i32]* @sortlist, i64 0, i64 %idxprom
10   %div = sdiv i64 %conv, 100000
4   %i.0 = phi i32 [ 1, %entry ], [ %inc, %for.inc ]
21   %0 = load i32, i32* %arrayidx4, align 4
22   %1 = load i32, i32* @biggest, align 4
23   %cmp5 = icmp sgt i32 %0, %1
16   %idxprom = sext i32 %i.0 to i64
3   store i32 0, i32* @littlest, align 4
20   store i32 %conv2, i32* %arrayidx, align 4
2   store i32 0, i32* @biggest, align 4
1   call void @Initrand()
Block: if.end
7   %call = call i32 @Rand()
15   %conv2 = trunc i64 %sub1 to i32
6   %cmp = icmp sle i32 %i.0, 5000
14   %sub1 = sub nsw i64 %sub, 50000
12   %sub = sub nsw i64 %conv, %mul
8   %conv = sext i32 %call to i64
11   %mul = mul nsw i64 %div, 100000
19   %arrayidx = getelementptr inbounds [5001 x i32], [5001 x i32]* @sortlist, i64 0, i64 %idxprom
10   %div = sdiv i64 %conv, 100000
4   %i.0 = phi i32 [ 1, %entry ], [ %inc, %for.inc ]
21   %0 = load i32, i32* %arrayidx4, align 4
22   %1 = load i32, i32* @biggest, align 4
23   %cmp5 = icmp sgt i32 %0, %1
28   %3 = load i32, i32* %arrayidx10, align 4
16   %idxprom = sext i32 %i.0 to i64
3   store i32 0, i32* @littlest, align 4
29   %4 = load i32, i32* @littlest, align 4
20   store i32 %conv2, i32* %arrayidx, align 4
2   store i32 0, i32* @biggest, align 4
30   %cmp11 = icmp slt i32 %3, %4
1   call void @Initrand()
Block: if.else
7   %call = call i32 @Rand()
15   %conv2 = trunc i64 %sub1 to i32
6   %cmp = icmp sle i32 %i.0, 5000
14   %sub1 = sub nsw i64 %sub, 50000
12   %sub = sub nsw i64 %conv, %mul
8   %conv = sext i32 %call to i64
11   %mul = mul nsw i64 %div, 100000
19   %arrayidx = getelementptr inbounds [5001 x i32], [5001 x i32]* @sortlist, i64 0, i64 %idxprom
10   %div = sdiv i64 %conv, 100000
4   %i.0 = phi i32 [ 1, %entry ], [ %inc, %for.inc ]
21   %0 = load i32, i32* %arrayidx4, align 4
22   %1 = load i32, i32* @biggest, align 4
23   %cmp5 = icmp sgt i32 %0, %1
28   %3 = load i32, i32* %arrayidx10, align 4
16   %idxprom = sext i32 %i.0 to i64
3   store i32 0, i32* @littlest, align 4
29   %4 = load i32, i32* @littlest, align 4
20   store i32 %conv2, i32* %arrayidx, align 4
2   store i32 0, i32* @biggest, align 4
30   %cmp11 = icmp slt i32 %3, %4
1   call void @Initrand()
Block: if.then13
7   %call = call i32 @Rand()
15   %conv2 = trunc i64 %sub1 to i32
6   %cmp = icmp sle i32 %i.0, 5000
14   %sub1 = sub nsw i64 %sub, 50000
32   store i32 %5, i32* @littlest, align 4
12   %sub = sub nsw i64 %conv, %mul
8   %conv = sext i32 %call to i64
11   %mul = mul nsw i64 %div, 100000
19   %arrayidx = getelementptr inbounds [5001 x i32], [5001 x i32]* @sortlist, i64 0, i64 %idxprom
10   %div = sdiv i64 %conv, 100000
4   %i.0 = phi i32 [ 1, %entry ], [ %inc, %for.inc ]
21   %0 = load i32, i32* %arrayidx4, align 4
22   %1 = load i32, i32* @biggest, align 4
23   %cmp5 = icmp sgt i32 %0, %1
31   %5 = load i32, i32* %arrayidx15, align 4
28   %3 = load i32, i32* %arrayidx10, align 4
16   %idxprom = sext i32 %i.0 to i64
3   store i32 0, i32* @littlest, align 4
29   %4 = load i32, i32* @littlest, align 4
20   store i32 %conv2, i32* %arrayidx, align 4
2   store i32 0, i32* @biggest, align 4
30   %cmp11 = icmp slt i32 %3, %4
1   call void @Initrand()
Block: for.body
7   %call = call i32 @Rand()
15   %conv2 = trunc i64 %sub1 to i32
6   %cmp = icmp sle i32 %i.0, 5000
14   %sub1 = sub nsw i64 %sub, 50000
12   %sub = sub nsw i64 %conv, %mul
8   %conv = sext i32 %call to i64
11   %mul = mul nsw i64 %div, 100000
19   %arrayidx = getelementptr inbounds [5001 x i32], [5001 x i32]* @sortlist, i64 0, i64 %idxprom
10   %div = sdiv i64 %conv, 100000
4   %i.0 = phi i32 [ 1, %entry ], [ %inc, %for.inc ]
21   %0 = load i32, i32* %arrayidx4, align 4
22   %1 = load i32, i32* @biggest, align 4
23   %cmp5 = icmp sgt i32 %0, %1
16   %idxprom = sext i32 %i.0 to i64
3   store i32 0, i32* @littlest, align 4
20   store i32 %conv2, i32* %arrayidx, align 4
2   store i32 0, i32* @biggest, align 4
1   call void @Initrand()
Block: if.then
25   store i32 %2, i32* @biggest, align 4
7   %call = call i32 @Rand()
15   %conv2 = trunc i64 %sub1 to i32
6   %cmp = icmp sle i32 %i.0, 5000
14   %sub1 = sub nsw i64 %sub, 50000
12   %sub = sub nsw i64 %conv, %mul
8   %conv = sext i32 %call to i64
11   %mul = mul nsw i64 %div, 100000
19   %arrayidx = getelementptr inbounds [5001 x i32], [5001 x i32]* @sortlist, i64 0, i64 %idxprom
10   %div = sdiv i64 %conv, 100000
24   %2 = load i32, i32* %arrayidx8, align 4
4   %i.0 = phi i32 [ 1, %entry ], [ %inc, %for.inc ]
21   %0 = load i32, i32* %arrayidx4, align 4
22   %1 = load i32, i32* @biggest, align 4
23   %cmp5 = icmp sgt i32 %0, %1
16   %idxprom = sext i32 %i.0 to i64
3   store i32 0, i32* @littlest, align 4
20   store i32 %conv2, i32* %arrayidx, align 4
2   store i32 0, i32* @biggest, align 4
1   call void @Initrand()
Block: for.cond
1   call void @Initrand()
2   store i32 0, i32* @biggest, align 4
3   store i32 0, i32* @littlest, align 4
4   %i.0 = phi i32 [ 1, %entry ], [ %inc, %for.inc ]
6   %cmp = icmp sle i32 %i.0, 5000
Block: entry
1   call void @Initrand()
2   store i32 0, i32* @biggest, align 4
3   store i32 0, i32* @littlest, align 4
anticipateIn for each Basic Block 
Block: if.else.if.end_crit_edge
27   %inc = add nsw i32 %i.0, 1
7   %call = call i32 @Rand()
29   %4 = load i32, i32* @littlest, align 4
22   %1 = load i32, i32* @biggest, align 4
Block: for.end
Block: for.inc
27   %inc = add nsw i32 %i.0, 1
7   %call = call i32 @Rand()
29   %4 = load i32, i32* @littlest, align 4
22   %1 = load i32, i32* @biggest, align 4
Block: if.end16
27   %inc = add nsw i32 %i.0, 1
7   %call = call i32 @Rand()
29   %4 = load i32, i32* @littlest, align 4
22   %1 = load i32, i32* @biggest, align 4
Block: if.end
27   %inc = add nsw i32 %i.0, 1
7   %call = call i32 @Rand()
29   %4 = load i32, i32* @littlest, align 4
22   %1 = load i32, i32* @biggest, align 4
Block: if.else
27   %inc = add nsw i32 %i.0, 1
4   %i.0 = phi i32 [ 1, %entry ], [ %inc, %for.inc ]
7   %call = call i32 @Rand()
29   %4 = load i32, i32* @littlest, align 4
16   %idxprom14 = sext i32 %i.0 to i64
22   %1 = load i32, i32* @biggest, align 4
Block: if.then13
27   %inc = add nsw i32 %i.0, 1
7   %call = call i32 @Rand()
29   %4 = load i32, i32* @littlest, align 4
22   %1 = load i32, i32* @biggest, align 4
4   %i.0 = phi i32 [ 1, %entry ], [ %inc, %for.inc ]
16   %idxprom14 = sext i32 %i.0 to i64
Block: for.body
27   %inc = add nsw i32 %i.0, 1
4   %i.0 = phi i32 [ 1, %entry ], [ %inc, %for.inc ]
7   %call = call i32 @Rand()
16   %idxprom7 = sext i32 %i.0 to i64
29   %4 = load i32, i32* @littlest, align 4
16   %idxprom14 = sext i32 %i.0 to i64
22   %1 = load i32, i32* @biggest, align 4
Block: if.then
27   %inc = add nsw i32 %i.0, 1
7   %call = call i32 @Rand()
29   %4 = load i32, i32* @littlest, align 4
22   %1 = load i32, i32* @biggest, align 4
4   %i.0 = phi i32 [ 1, %entry ], [ %inc, %for.inc ]
16   %idxprom7 = sext i32 %i.0 to i64
Block: for.cond
4   %i.0 = phi i32 [ 1, %entry ], [ %inc, %for.inc ]
7   %call = call i32 @Rand()
29   %4 = load i32, i32* @littlest, align 4
22   %1 = load i32, i32* @biggest, align 4
Block: entry
26 i32 1
7   %call = call i32 @Rand()
29   %4 = load i32, i32* @littlest, align 4
22   %1 = load i32, i32* @biggest, align 4
33
available out point of each value number0: 
1: for.cond if.then for.body if.then13 entry if.else if.end for.inc for.end if.end16 if.else.if.end_crit_edge 
2: for.cond if.then for.body if.then13 entry if.else if.end for.inc for.end if.end16 if.else.if.end_crit_edge 
3: for.cond if.then for.body if.then13 entry if.else if.end for.inc for.end if.end16 if.else.if.end_crit_edge 
4: for.cond if.then for.body if.then13 if.else if.end for.inc for.end if.end16 if.else.if.end_crit_edge 
5: 
6: for.cond if.then for.body if.then13 if.else if.end for.inc for.end if.end16 if.else.if.end_crit_edge 
7: if.then for.body if.then13 if.else if.end for.inc if.end16 if.else.if.end_crit_edge 
8: if.then for.body if.then13 if.else if.end for.inc if.end16 if.else.if.end_crit_edge 
9: 
10: if.then for.body if.then13 if.else if.end for.inc if.end16 if.else.if.end_crit_edge 
11: if.then for.body if.then13 if.else if.end for.inc if.end16 if.else.if.end_crit_edge 
12: if.then for.body if.then13 if.else if.end for.inc if.end16 if.else.if.end_crit_edge 
13: 
14: if.then for.body if.then13 if.else if.end for.inc if.end16 if.else.if.end_crit_edge 
15: if.then for.body if.then13 if.else if.end for.inc if.end16 if.else.if.end_crit_edge 
16: if.then for.body if.then13 if.else if.end for.inc if.end16 if.else.if.end_crit_edge 
17: 
18: 
19: if.then for.body if.then13 if.else if.end for.inc if.end16 if.else.if.end_crit_edge 
20: if.then for.body if.then13 if.else if.end for.inc if.end16 if.else.if.end_crit_edge 
21: if.then for.body if.then13 if.else if.end for.inc if.end16 if.else.if.end_crit_edge 
22: if.then for.body if.then13 if.else if.end for.inc if.end16 if.else.if.end_crit_edge 
23: if.then for.body if.then13 if.else if.end for.inc if.end16 if.else.if.end_crit_edge 
24: if.then 
25: if.then 
26: 
27: for.inc 
28: if.then13 if.else if.end if.else.if.end_crit_edge 
29: if.then13 if.else if.end if.else.if.end_crit_edge 
30: if.then13 if.else if.end if.else.if.end_crit_edge 
31: if.then13 
32: if.then13 
antipate in point of each value number0: 
1: 
2: 
3: 
4: for.cond if.then for.body if.then13 if.else 
5: 
6: 
7: for.cond if.then for.body if.then13 entry if.else if.end for.inc if.end16 if.else.if.end_crit_edge 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: if.then for.body if.then13 if.else 
17: 
18: 
19: 
20: 
21: 
22: for.cond if.then for.body if.then13 entry if.else if.end for.inc if.end16 if.else.if.end_crit_edge 
23: 
24: 
25: 
26: entry 
27: if.then for.body if.then13 if.else if.end for.inc if.end16 if.else.if.end_crit_edge 
28: 
29: for.cond if.then for.body if.then13 entry if.else if.end for.inc if.end16 if.else.if.end_crit_edge 
30: 
31: 
32: 
valunumber: 0
0				0				
0				0				
min cut from 0 to 1
valunumber: 1
0				0				
0				0				
min cut from 0 to 1
valunumber: 2
0				0				
0				0				
min cut from 0 to 1
valunumber: 3
0				0				
0				0				
min cut from 0 to 1
valunumber: 4
entry to for.cond: 8 1.000000e+00
0				9				0				0				
0				0				0				2147483647				
2147483647				0				0				0				
0				0				0				0				
min cut from 2 to 3
entry - for.cond
valunumber: 5
0				0				
0				0				
min cut from 0 to 1
valunumber: 6
0				0				
0				0				
min cut from 0 to 1
valunumber: 7
entry to for.cond: 8 1.000000e+00
for.cond to for.body: 256 9.687500e-01
0				9				0				0				0				
0				0				249				0				0				
0				0				0				0				2147483647				
2147483647				0				0				0				0				
0				0				0				0				0				
min cut from 3 to 4
entry - for.cond
valunumber: 8
0				0				
0				0				
min cut from 0 to 1
valunumber: 9
0				0				
0				0				
min cut from 0 to 1
valunumber: 10
0				0				
0				0				
min cut from 0 to 1
valunumber: 11
0				0				
0				0				
min cut from 0 to 1
valunumber: 12
0				0				
0				0				
min cut from 0 to 1
valunumber: 13
0				0				
0				0				
min cut from 0 to 1
valunumber: 14
0				0				
0				0				
min cut from 0 to 1
valunumber: 15
0				0				
0				0				
min cut from 0 to 1
valunumber: 16
for.cond to for.body: 256 9.687500e-01
0				249				0				0				
0				0				0				2147483647				
2147483647				0				0				0				
0				0				0				0				
min cut from 2 to 3
for.cond - for.body
valunumber: 17
0				0				
0				0				
min cut from 0 to 1
valunumber: 18
0				0				
0				0				
min cut from 0 to 1
valunumber: 19
0				0				
0				0				
min cut from 0 to 1
valunumber: 20
0				0				
0				0				
min cut from 0 to 1
valunumber: 21
0				0				
0				0				
min cut from 0 to 1
valunumber: 22
entry to for.cond: 8 1.000000e+00
for.cond to for.body: 256 9.687500e-01
0				9				0				0				0				
0				0				249				0				0				
0				0				0				0				2147483647				
2147483647				0				0				0				0				
0				0				0				0				0				
min cut from 3 to 4
entry - for.cond
valunumber: 23
0				0				
0				0				
min cut from 0 to 1
valunumber: 24
0				0				
0				0				
min cut from 0 to 1
valunumber: 25
0				0				
0				0				
min cut from 0 to 1
valunumber: 26
0				0				
0				0				
min cut from 0 to 1
valunumber: 27
for.body to if.then: 248 5.000000e-01
for.cond to for.body: 256 9.687500e-01
if.else to if.then13: 124 5.000000e-01
for.body to if.else: 248 5.000000e-01
if.else.if.end_crit_edge to if.end: 62 1.000000e+00
if.then13 to if.end: 62 1.000000e+00
if.end16 to for.inc: 248 1.000000e+00
if.end to if.end16: 124 1.000000e+00
if.then to if.end16: 124 1.000000e+00
if.else to if.else.if.end_crit_edge: 124 5.000000e-01
0				125				0				125				0				0				0				0				0				0				0				
0				0				0				0				0				0				0				125				0				0				0				
249				0				0				0				0				0				0				0				0				0				0				
0				0				0				0				63				63				0				0				0				0				0				
0				0				0				0				0				0				63				0				0				0				0				
0				0				0				0				0				0				63				0				0				0				0				
0				0				0				0				0				0				0				125				0				0				0				
0				0				0				0				0				0				0				0				249				0				0				
0				0				0				0				0				0				0				0				0				0				2147483647				
0				0				2147483647				0				0				0				0				0				0				0				0				
0				0				0				0				0				0				0				0				0				0				0				
min cut from 9 to 10
for.cond - for.body
valunumber: 28
0				0				
0				0				
min cut from 0 to 1
valunumber: 29
for.inc to for.cond: 248 1.000000e+00
entry to for.cond: 8 1.000000e+00
for.body to if.then: 248 5.000000e-01
for.cond to for.body: 256 9.687500e-01
for.body to if.else: 248 5.000000e-01
if.end16 to for.inc: 248 1.000000e+00
if.then to if.end16: 124 1.000000e+00
0				249				0				0				0				0				0				0				0				
0				0				0				249				0				0				0				0				0				
0				9				0				0				0				0				0				0				0				
0				0				0				0				125				125				0				0				0				
0				0				0				0				0				0				125				0				0				
0				0				0				0				0				0				0				0				2147483647				
249				0				0				0				0				0				0				0				0				
0				0				2147483647				0				0				0				0				0				0				
0				0				0				0				0				0				0				0				0				
min cut from 7 to 8
entry - for.cond
valunumber: 30
0				0				
0				0				
min cut from 0 to 1
valunumber: 31
0				0				
0				0				
min cut from 0 to 1
valunumber: 32
0				0				
0				0				
min cut from 0 to 1
insert into for.body.split
available
  call void @Initrand()
  store i32 0, i32* @biggest, align 4
  store i32 0, i32* @littlest, align 4
  %i.0 = phi i32 [ 1, %entry ], [ %inc, %for.inc ]
  %cmp = icmp sle i32 %i.0, 5000
16 prepared
try   %idxprom14 = sext i32 %i.0 to i64
27 prepared
try   %inc = add nsw i32 %i.0, 1

for.body.split:                                   ; preds = %for.cond
  %OptInsert_idxprom14 = sext i32 %i.0 to i64
  %OptInsert_inc = add nsw i32 %i.0, 1
  br label %for.body

insert into entry.split
available
  call void @Initrand()
  store i32 0, i32* @biggest, align 4
  store i32 0, i32* @littlest, align 4
4 prepared
try   %i.0 = phi i32 [ 1, %entry.split ], [ %inc, %for.inc ]
7 prepared
try   %call = call i32 @Rand()
22 prepared
try   %1 = load i32, i32* @biggest, align 4
29 prepared
try   %4 = load i32, i32* @littlest, align 4

entry.split:                                      ; preds = %entry
  %OptInsert_call = call i32 @Rand()
  %OptInsert_ = load i32, i32* @biggest, align 4
  %OptInsert_1 = load i32, i32* @littlest, align 4
  br label %for.cond

if.then has dominance frontier:
if.end16 
if.else has dominance frontier:
if.end16 
if.end has dominance frontier:
if.end16 
if.then13 has dominance frontier:
if.end 
for.body.split has dominance frontier:
for.cond 
for.body has dominance frontier:
for.cond 
if.else.if.end_crit_edge has dominance frontier:
if.end 
if.end16 has dominance frontier:
for.cond 
for.inc has dominance frontier:
for.cond 
22 in newValueSet
  %OptInsert_ = load i32, i32* @biggest, align 4
22 in newDefined
  %OptInsert_ = load i32, i32* @biggest, align 4
7 in newValueSet
  %OptInsert_call = call i32 @Rand()
7 in newDefined
  %OptInsert_call = call i32 @Rand()
27 in newValueSet
  %OptInsert_inc = add nsw i32 %i.0, 1
27 in newDefined
  %OptInsert_inc = add nsw i32 %i.0, 1
29 in newValueSet
  %OptInsert_1 = load i32, i32* @littlest, align 4
29 in newDefined
  %OptInsert_1 = load i32, i32* @littlest, align 4
16 in newValueSet
  %OptInsert_idxprom14 = sext i32 %i.0 to i64
16 in newDefined
  %OptInsert_idxprom14 = sext i32 %i.0 to i64
revNewValue
29:   %OptInsert_1 = load i32, i32* @littlest, align 4
16:   %OptInsert_idxprom14 = sext i32 %i.0 to i64
27:   %OptInsert_inc = add nsw i32 %i.0, 1
7:   %OptInsert_call = call i32 @Rand()
22:   %OptInsert_ = load i32, i32* @biggest, align 4
rename: entry
  call void @Initrand()
  store i32 0, i32* @biggest, align 4
  store i32 0, i32* @littlest, align 4
  br label %entry.split
fill in phi

entry.split:                                      ; preds = %entry
  %OptInsert_call = call i32 @Rand()
  %OptInsert_ = load i32, i32* @biggest, align 4
  %OptInsert_1 = load i32, i32* @littlest, align 4
  br label %for.cond
rename: entry.split
  %OptInsert_call = call i32 @Rand()
  %OptInsert_ = load i32, i32* @biggest, align 4
  %OptInsert_1 = load i32, i32* @littlest, align 4
  br label %for.cond
fill in phi

for.cond:                                         ; preds = %for.inc, %entry.split
  %i.0 = phi i32 [ 1, %entry.split ], [ %inc, %for.inc ]
  %cmp = icmp sle i32 %i.0, 5000
  br i1 %cmp, label %for.body.split, label %for.end
  %inc = add nsw i32 %i.0, 1
rename: for.cond
  %i.0 = phi i32 [ 1, %entry.split ], [ %inc, %for.inc ]
  %cmp = icmp sle i32 %i.0, 5000
  %i.0 = phi i32 [ 1, %entry.split ], [ %inc, %for.inc ]
  br i1 %cmp, label %for.body.split, label %for.end
  %cmp = icmp sle i32 %i.0, 5000
fill in phi

for.body.split:                                   ; preds = %for.cond
  %OptInsert_idxprom14 = sext i32 %i.0 to i64
  %OptInsert_inc = add nsw i32 %i.0, 1
  br label %for.body

for.end:                                          ; preds = %for.cond
  ret void
rename: for.body.split
  %OptInsert_idxprom14 = sext i32 %i.0 to i64
  %i.0 = phi i32 [ 1, %entry.split ], [ %inc, %for.inc ]
  %OptInsert_inc = add nsw i32 %i.0, 1
  %i.0 = phi i32 [ 1, %entry.split ], [ %inc, %for.inc ]
  br label %for.body
fill in phi

for.body:                                         ; preds = %for.body.split
  %call = call i32 @Rand()
  %conv = sext i32 %call to i64
  %div = sdiv i64 %conv, 100000
  %mul = mul nsw i64 %div, 100000
  %sub = sub nsw i64 %conv, %mul
  %sub1 = sub nsw i64 %sub, 50000
  %conv2 = trunc i64 %sub1 to i32
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [5001 x i32], [5001 x i32]* @sortlist, i64 0, i64 %idxprom
  store i32 %conv2, i32* %arrayidx, align 4
  %idxprom3 = sext i32 %i.0 to i64
  %arrayidx4 = getelementptr inbounds [5001 x i32], [5001 x i32]* @sortlist, i64 0, i64 %idxprom3
  %0 = load i32, i32* %arrayidx4, align 4
  %1 = load i32, i32* @biggest, align 4
  %cmp5 = icmp sgt i32 %0, %1
  br i1 %cmp5, label %if.then, label %if.else
rename: for.body
  %call = call i32 @Rand()
  %conv = sext i32 %call to i64
  %call = call i32 @Rand()
  %div = sdiv i64 %conv, 100000
  %conv = sext i32 %OptInsert_call to i64
  %mul = mul nsw i64 %div, 100000
  %div = sdiv i64 %conv, 100000
  %sub = sub nsw i64 %conv, %mul
  %conv = sext i32 %OptInsert_call to i64
  %mul = mul nsw i64 %div, 100000
  %sub1 = sub nsw i64 %sub, 50000
  %sub = sub nsw i64 %conv, %mul
  %conv2 = trunc i64 %sub1 to i32
  %sub1 = sub nsw i64 %sub, 50000
  %idxprom = sext i32 %i.0 to i64
  %i.0 = phi i32 [ 1, %entry.split ], [ %inc, %for.inc ]
  %arrayidx = getelementptr inbounds [5001 x i32], [5001 x i32]* @sortlist, i64 0, i64 %idxprom
  %idxprom = sext i32 %i.0 to i64
  store i32 %conv2, i32* %arrayidx, align 4
  %conv2 = trunc i64 %sub1 to i32
  %arrayidx = getelementptr inbounds [5001 x i32], [5001 x i32]* @sortlist, i64 0, i64 %OptInsert_idxprom14
  %idxprom3 = sext i32 %i.0 to i64
  %i.0 = phi i32 [ 1, %entry.split ], [ %inc, %for.inc ]
  %arrayidx4 = getelementptr inbounds [5001 x i32], [5001 x i32]* @sortlist, i64 0, i64 %idxprom3
  %idxprom3 = sext i32 %i.0 to i64
  %0 = load i32, i32* %arrayidx4, align 4
  %arrayidx4 = getelementptr inbounds [5001 x i32], [5001 x i32]* @sortlist, i64 0, i64 %OptInsert_idxprom14
  %1 = load i32, i32* @biggest, align 4
  %cmp5 = icmp sgt i32 %0, %1
  %0 = load i32, i32* %arrayidx4, align 4
  %1 = load i32, i32* @biggest, align 4
  br i1 %cmp5, label %if.then, label %if.else
  %cmp5 = icmp sgt i32 %0, %OptInsert_
fill in phi

if.then:                                          ; preds = %for.body
  %idxprom7 = sext i32 %i.0 to i64
  %arrayidx8 = getelementptr inbounds [5001 x i32], [5001 x i32]* @sortlist, i64 0, i64 %idxprom7
  %2 = load i32, i32* %arrayidx8, align 4
  store i32 %2, i32* @biggest, align 4
  br label %if.end16

if.else:                                          ; preds = %for.body
  %idxprom9 = sext i32 %i.0 to i64
  %arrayidx10 = getelementptr inbounds [5001 x i32], [5001 x i32]* @sortlist, i64 0, i64 %idxprom9
  %3 = load i32, i32* %arrayidx10, align 4
  %4 = load i32, i32* @littlest, align 4
  %cmp11 = icmp slt i32 %3, %4
  br i1 %cmp11, label %if.then13, label %if.else.if.end_crit_edge
rename: if.then
  %idxprom7 = sext i32 %i.0 to i64
  %i.0 = phi i32 [ 1, %entry.split ], [ %inc, %for.inc ]
  %arrayidx8 = getelementptr inbounds [5001 x i32], [5001 x i32]* @sortlist, i64 0, i64 %idxprom7
  %idxprom7 = sext i32 %i.0 to i64
  %2 = load i32, i32* %arrayidx8, align 4
  %arrayidx8 = getelementptr inbounds [5001 x i32], [5001 x i32]* @sortlist, i64 0, i64 %OptInsert_idxprom14
  store i32 %2, i32* @biggest, align 4
  %2 = load i32, i32* %arrayidx8, align 4
  br label %if.end16
fill in phi

if.end16:                                         ; preds = %if.end, %if.then
  br label %for.inc
rename: if.end16
  br label %for.inc
fill in phi

for.inc:                                          ; preds = %if.end16
  %inc = add nsw i32 %i.0, 1
  br label %for.cond, !llvm.loop !31
rename: for.inc
  %inc = add nsw i32 %i.0, 1
  %i.0 = phi i32 [ 1, %entry.split ], [ %inc, %for.inc ]
  br label %for.cond, !llvm.loop !31
fill in phi

for.cond:                                         ; preds = %for.inc, %entry.split
  %i.0 = phi i32 [ 1, %entry.split ], [ %inc, %for.inc ]
  %cmp = icmp sle i32 %i.0, 5000
  br i1 %cmp, label %for.body.split, label %for.end
  %inc = add nsw i32 %i.0, 1
rename: if.else
  %idxprom9 = sext i32 %i.0 to i64
  %i.0 = phi i32 [ 1, %entry.split ], [ %OptInsert_inc, %for.inc ]
  %arrayidx10 = getelementptr inbounds [5001 x i32], [5001 x i32]* @sortlist, i64 0, i64 %idxprom9
  %idxprom9 = sext i32 %i.0 to i64
  %3 = load i32, i32* %arrayidx10, align 4
  %arrayidx10 = getelementptr inbounds [5001 x i32], [5001 x i32]* @sortlist, i64 0, i64 %OptInsert_idxprom14
  %4 = load i32, i32* @littlest, align 4
  %cmp11 = icmp slt i32 %3, %4
  %3 = load i32, i32* %arrayidx10, align 4
  %4 = load i32, i32* @littlest, align 4
  br i1 %cmp11, label %if.then13, label %if.else.if.end_crit_edge
  %cmp11 = icmp slt i32 %3, %OptInsert_1
fill in phi

if.then13:                                        ; preds = %if.else
  %idxprom14 = sext i32 %i.0 to i64
  %arrayidx15 = getelementptr inbounds [5001 x i32], [5001 x i32]* @sortlist, i64 0, i64 %idxprom14
  %5 = load i32, i32* %arrayidx15, align 4
  store i32 %5, i32* @littlest, align 4
  br label %if.end

if.else.if.end_crit_edge:                         ; preds = %if.else
  br label %if.end
rename: if.then13
  %idxprom14 = sext i32 %i.0 to i64
  %i.0 = phi i32 [ 1, %entry.split ], [ %OptInsert_inc, %for.inc ]
  %arrayidx15 = getelementptr inbounds [5001 x i32], [5001 x i32]* @sortlist, i64 0, i64 %idxprom14
  %idxprom14 = sext i32 %i.0 to i64
  %5 = load i32, i32* %arrayidx15, align 4
  %arrayidx15 = getelementptr inbounds [5001 x i32], [5001 x i32]* @sortlist, i64 0, i64 %OptInsert_idxprom14
  store i32 %5, i32* @littlest, align 4
  %5 = load i32, i32* %arrayidx15, align 4
  br label %if.end
fill in phi

if.end:                                           ; preds = %if.else.if.end_crit_edge, %if.then13
  br label %if.end16
rename: if.end
  br label %if.end16
fill in phi

if.end16:                                         ; preds = %if.end, %if.then
  br label %for.inc
rename: if.else.if.end_crit_edge
  br label %if.end
fill in phi

if.end:                                           ; preds = %if.else.if.end_crit_edge, %if.then13
  br label %if.end16
rename: for.end
  ret void
fill in phi

entry:
  call void @Initrand()
  store i32 0, i32* @biggest, align 4
  store i32 0, i32* @littlest, align 4
  br label %entry.split


entry.split:                                      ; preds = %entry
  %OptInsert_call = call i32 @Rand()
  %OptInsert_ = load i32, i32* @biggest, align 4
  %OptInsert_1 = load i32, i32* @littlest, align 4
  br label %for.cond


for.cond:                                         ; preds = %for.inc, %entry.split
  %i.0 = phi i32 [ 1, %entry.split ], [ %OptInsert_inc, %for.inc ]
  %cmp = icmp sle i32 %i.0, 5000
  br i1 %cmp, label %for.body.split, label %for.end


for.body.split:                                   ; preds = %for.cond
  %OptInsert_idxprom14 = sext i32 %i.0 to i64
  %OptInsert_inc = add nsw i32 %i.0, 1
  br label %for.body


for.body:                                         ; preds = %for.body.split
  %call = call i32 @Rand()
  %conv = sext i32 %OptInsert_call to i64
  %div = sdiv i64 %conv, 100000
  %mul = mul nsw i64 %div, 100000
  %sub = sub nsw i64 %conv, %mul
  %sub1 = sub nsw i64 %sub, 50000
  %conv2 = trunc i64 %sub1 to i32
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [5001 x i32], [5001 x i32]* @sortlist, i64 0, i64 %OptInsert_idxprom14
  store i32 %conv2, i32* %arrayidx, align 4
  %idxprom3 = sext i32 %i.0 to i64
  %arrayidx4 = getelementptr inbounds [5001 x i32], [5001 x i32]* @sortlist, i64 0, i64 %OptInsert_idxprom14
  %0 = load i32, i32* %arrayidx4, align 4
  %1 = load i32, i32* @biggest, align 4
  %cmp5 = icmp sgt i32 %0, %OptInsert_
  br i1 %cmp5, label %if.then, label %if.else


if.then:                                          ; preds = %for.body
  %idxprom7 = sext i32 %i.0 to i64
  %arrayidx8 = getelementptr inbounds [5001 x i32], [5001 x i32]* @sortlist, i64 0, i64 %OptInsert_idxprom14
  %2 = load i32, i32* %arrayidx8, align 4
  store i32 %2, i32* @biggest, align 4
  br label %if.end16


if.else:                                          ; preds = %for.body
  %idxprom9 = sext i32 %i.0 to i64
  %arrayidx10 = getelementptr inbounds [5001 x i32], [5001 x i32]* @sortlist, i64 0, i64 %OptInsert_idxprom14
  %3 = load i32, i32* %arrayidx10, align 4
  %4 = load i32, i32* @littlest, align 4
  %cmp11 = icmp slt i32 %3, %OptInsert_1
  br i1 %cmp11, label %if.then13, label %if.else.if.end_crit_edge


if.else.if.end_crit_edge:                         ; preds = %if.else
  br label %if.end


if.then13:                                        ; preds = %if.else
  %idxprom14 = sext i32 %i.0 to i64
  %arrayidx15 = getelementptr inbounds [5001 x i32], [5001 x i32]* @sortlist, i64 0, i64 %OptInsert_idxprom14
  %5 = load i32, i32* %arrayidx15, align 4
  store i32 %5, i32* @littlest, align 4
  br label %if.end


if.end:                                           ; preds = %if.else.if.end_crit_edge, %if.then13
  br label %if.end16


if.end16:                                         ; preds = %if.end, %if.then
  br label %for.inc


for.inc:                                          ; preds = %if.end16
  %inc = add nsw i32 %i.0, 1
  br label %for.cond, !llvm.loop !31


for.end:                                          ; preds = %for.cond
  ret void

entry
  call void @Initrand()
  store i32 0, i32* @biggest, align 4
  store i32 0, i32* @littlest, align 4
  br label %entry.split
entry.split
  %OptInsert_call = call i32 @Rand()
  %OptInsert_ = load i32, i32* @biggest, align 4
  %OptInsert_1 = load i32, i32* @littlest, align 4
  br label %for.cond
for.cond
  %i.0 = phi i32 [ 1, %entry.split ], [ %OptInsert_inc, %for.inc ]
  %i.0 = phi i32 [ 1, %entry.split ], [ %OptInsert_inc, %for.inc ]
  %cmp = icmp sle i32 %i.0, 5000
  br i1 %cmp, label %for.body.split, label %for.end
for.body.split
  %OptInsert_idxprom14 = sext i32 %i.0 to i64
  %OptInsert_inc = add nsw i32 %i.0, 1
  br label %for.body
for.body
  %call = call i32 @Rand()
  %conv = sext i32 %OptInsert_call to i64
  %div = sdiv i64 %conv, 100000
  %mul = mul nsw i64 %div, 100000
  %sub = sub nsw i64 %conv, %mul
  %sub1 = sub nsw i64 %sub, 50000
  %conv2 = trunc i64 %sub1 to i32
  %idxprom = sext i32 %i.0 to i64
  %arrayidx = getelementptr inbounds [5001 x i32], [5001 x i32]* @sortlist, i64 0, i64 %OptInsert_idxprom14
  store i32 %conv2, i32* %arrayidx, align 4
  %idxprom3 = sext i32 %i.0 to i64
  %arrayidx4 = getelementptr inbounds [5001 x i32], [5001 x i32]* @sortlist, i64 0, i64 %OptInsert_idxprom14
  %0 = load i32, i32* %arrayidx4, align 4
  %1 = load i32, i32* @biggest, align 4
  %cmp5 = icmp sgt i32 %0, %OptInsert_
  br i1 %cmp5, label %if.then, label %if.else
if.then
  %idxprom7 = sext i32 %i.0 to i64
  %arrayidx8 = getelementptr inbounds [5001 x i32], [5001 x i32]* @sortlist, i64 0, i64 %OptInsert_idxprom14
  %2 = load i32, i32* %arrayidx8, align 4
  store i32 %2, i32* @biggest, align 4
  br label %if.end16
if.else
  %idxprom9 = sext i32 %i.0 to i64
  %arrayidx10 = getelementptr inbounds [5001 x i32], [5001 x i32]* @sortlist, i64 0, i64 %OptInsert_idxprom14
  %3 = load i32, i32* %arrayidx10, align 4
  %4 = load i32, i32* @littlest, align 4
  %cmp11 = icmp slt i32 %3, %OptInsert_1
  br i1 %cmp11, label %if.then13, label %if.else.if.end_crit_edge
if.else.if.end_crit_edge
  br label %if.end
if.then13
  %idxprom14 = sext i32 %i.0 to i64
  %arrayidx15 = getelementptr inbounds [5001 x i32], [5001 x i32]* @sortlist, i64 0, i64 %OptInsert_idxprom14
  %5 = load i32, i32* %arrayidx15, align 4
  store i32 %5, i32* @littlest, align 4
  br label %if.end
if.end
  br label %if.end16
if.end16
  br label %for.inc
for.inc
  %inc = add nsw i32 %i.0, 1
  br label %for.cond, !llvm.loop !31
for.end
  ret void
begin
changed
entry
new
  %call = call noalias i8* @malloc(i64 24) #4
  %1 = load %struct.node*, %struct.node** %t, align 8
  %2 = load %struct.node*, %struct.node** %t, align 8
  %3 = load %struct.node*, %struct.node** %t, align 8
changed
entry
  %call = call noalias i8* @malloc(i64 24) #4
  %1 = load %struct.node*, %struct.node** %t, align 8
  %2 = load %struct.node*, %struct.node** %t, align 8
  %3 = load %struct.node*, %struct.node** %t, align 8
avaiableOut for each Basic Block 
Block: entry
6   %left = getelementptr inbounds %struct.node, %struct.node* %1, i32 0, i32 0
7   store %struct.node* null, %struct.node** %left, align 8
4   %1 = load %struct.node*, %struct.node** %t, align 8
3   store %struct.node* %0, %struct.node** %t, align 8
2   %0 = bitcast i8* %call to %struct.node*
1   %call = call noalias i8* @malloc(i64 24) #4
15   store i32 %n, i32* %val, align 8
14   %val = getelementptr inbounds %struct.node, %struct.node* %3, i32 0, i32 2
11   store %struct.node* null, %struct.node** %right, align 8
12   %3 = load %struct.node*, %struct.node** %t, align 8
10   %right = getelementptr inbounds %struct.node, %struct.node* %2, i32 0, i32 1
8   %2 = load %struct.node*, %struct.node** %t, align 8
anticipateIn for each Basic Block 
Block: entry
1   %call = call noalias i8* @malloc(i64 24) #4
4   %1 = load %struct.node*, %struct.node** %t, align 8
8   %2 = load %struct.node*, %struct.node** %t, align 8
12   %3 = load %struct.node*, %struct.node** %t, align 8
16
available out point of each value number0: 
1: entry 
2: entry 
3: entry 
4: entry 
5: 
6: entry 
7: entry 
8: entry 
9: 
10: entry 
11: entry 
12: entry 
13: 
14: entry 
15: entry 
antipate in point of each value number0: 
1: entry 
2: 
3: 
4: entry 
5: 
6: 
7: 
8: entry 
9: 
10: 
11: 
12: entry 
13: 
14: 
15: 
valunumber: 0
0				0				
0				0				
min cut from 0 to 1
valunumber: 1
0				0				
0				0				
min cut from 0 to 1
valunumber: 2
0				0				
0				0				
min cut from 0 to 1
valunumber: 3
0				0				
0				0				
min cut from 0 to 1
valunumber: 4
0				0				
0				0				
min cut from 0 to 1
valunumber: 5
0				0				
0				0				
min cut from 0 to 1
valunumber: 6
0				0				
0				0				
min cut from 0 to 1
valunumber: 7
0				0				
0				0				
min cut from 0 to 1
valunumber: 8
0				0				
0				0				
min cut from 0 to 1
valunumber: 9
0				0				
0				0				
min cut from 0 to 1
valunumber: 10
0				0				
0				0				
min cut from 0 to 1
valunumber: 11
0				0				
0				0				
min cut from 0 to 1
valunumber: 12
0				0				
0				0				
min cut from 0 to 1
valunumber: 13
0				0				
0				0				
min cut from 0 to 1
valunumber: 14
0				0				
0				0				
min cut from 0 to 1
valunumber: 15
0				0				
0				0				
min cut from 0 to 1
revNewValue
rename: entry
  %call = call noalias i8* @malloc(i64 24) #4
  %0 = bitcast i8* %call to %struct.node*
  %call = call noalias i8* @malloc(i64 24) #4
  store %struct.node* %0, %struct.node** %t, align 8
  %0 = bitcast i8* %call to %struct.node*
  %1 = load %struct.node*, %struct.node** %t, align 8
  %left = getelementptr inbounds %struct.node, %struct.node* %1, i32 0, i32 0
  %1 = load %struct.node*, %struct.node** %t, align 8
  store %struct.node* null, %struct.node** %left, align 8
  %left = getelementptr inbounds %struct.node, %struct.node* %1, i32 0, i32 0
  %2 = load %struct.node*, %struct.node** %t, align 8
  %right = getelementptr inbounds %struct.node, %struct.node* %2, i32 0, i32 1
  %2 = load %struct.node*, %struct.node** %t, align 8
  store %struct.node* null, %struct.node** %right, align 8
  %right = getelementptr inbounds %struct.node, %struct.node* %2, i32 0, i32 1
  %3 = load %struct.node*, %struct.node** %t, align 8
  %val = getelementptr inbounds %struct.node, %struct.node* %3, i32 0, i32 2
  %3 = load %struct.node*, %struct.node** %t, align 8
  store i32 %n, i32* %val, align 8
  %val = getelementptr inbounds %struct.node, %struct.node* %3, i32 0, i32 2
  ret void
fill in phi

entry:
  %call = call noalias i8* @malloc(i64 24) #4
  %0 = bitcast i8* %call to %struct.node*
  store %struct.node* %0, %struct.node** %t, align 8
  %1 = load %struct.node*, %struct.node** %t, align 8
  %left = getelementptr inbounds %struct.node, %struct.node* %1, i32 0, i32 0
  store %struct.node* null, %struct.node** %left, align 8
  %2 = load %struct.node*, %struct.node** %t, align 8
  %right = getelementptr inbounds %struct.node, %struct.node* %2, i32 0, i32 1
  store %struct.node* null, %struct.node** %right, align 8
  %3 = load %struct.node*, %struct.node** %t, align 8
  %val = getelementptr inbounds %struct.node, %struct.node* %3, i32 0, i32 2
  store i32 %n, i32* %val, align 8
  ret void

entry
  %call = call noalias i8* @malloc(i64 24) #4
  %0 = bitcast i8* %call to %struct.node*
  store %struct.node* %0, %struct.node** %t, align 8
  %1 = load %struct.node*, %struct.node** %t, align 8
  %left = getelementptr inbounds %struct.node, %struct.node* %1, i32 0, i32 0
  store %struct.node* null, %struct.node** %left, align 8
  %2 = load %struct.node*, %struct.node** %t, align 8
  %right = getelementptr inbounds %struct.node, %struct.node* %2, i32 0, i32 1
  store %struct.node* null, %struct.node** %right, align 8
  %3 = load %struct.node*, %struct.node** %t, align 8
  %val = getelementptr inbounds %struct.node, %struct.node* %3, i32 0, i32 2
  store i32 %n, i32* %val, align 8
  ret void
begin
changed
if.end16
if.end
if.then2
new
  %left3 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 0
if.else
new
  %left4 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 0
if.then
new
  %left3 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 0
  %left4 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 0
if.end15
if.end14
if.then10
new
  %right11 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
if.else12
new
  %right13 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
if.then8
new
  %right11 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
  %right13 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
if.else5.if.end15_crit_edge
if.else5
new
  %right11 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
  %right13 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
  %val6 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 2
entry
new
  %left3 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 0
  %left4 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 0
  %right11 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
  %right13 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
  %val6 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 2
changed
if.then2
  %left3 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 0
if.else
  %left4 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 0
if.then
  %left3 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 0
  %left4 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 0
if.then10
  %right11 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
if.else12
  %right13 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
if.then8
  %right11 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
  %right13 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
if.else5
  %right11 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
  %right13 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
  %val6 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 2
entry
  %left3 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 0
  %left4 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 0
  %right11 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
  %right13 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
  %val6 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 2
avaiableOut for each Basic Block 
Block: entry
4   %val = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 2
5   %0 = load i32, i32* %val, align 8
7   %cmp = icmp sgt i32 %n, %0
Block: if.end
4   %val = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 2
5   %0 = load i32, i32* %val, align 8
7   %cmp = icmp sgt i32 %n, %0
8   %left = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 0
9   %1 = load %struct.node*, %struct.node** %left, align 8
11   %cmp1 = icmp eq %struct.node* %1, null
Block: if.else5
4   %val = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 2
5   %0 = load i32, i32* %val, align 8
7   %cmp = icmp sgt i32 %n, %0
15   %3 = load i32, i32* %val6, align 8
16   %cmp7 = icmp slt i32 %n, %3
Block: if.else
4   %val = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 2
5   %0 = load i32, i32* %val, align 8
7   %cmp = icmp sgt i32 %n, %0
8   %left = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 0
9   %1 = load %struct.node*, %struct.node** %left, align 8
11   %cmp1 = icmp eq %struct.node* %1, null
13   %2 = load %struct.node*, %struct.node** %left4, align 8
14   call void @Insert(i32 %n, %struct.node* %2)
Block: if.then
4   %val = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 2
5   %0 = load i32, i32* %val, align 8
7   %cmp = icmp sgt i32 %n, %0
8   %left = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 0
9   %1 = load %struct.node*, %struct.node** %left, align 8
11   %cmp1 = icmp eq %struct.node* %1, null
Block: if.then2
4   %val = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 2
5   %0 = load i32, i32* %val, align 8
7   %cmp = icmp sgt i32 %n, %0
8   %left = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 0
9   %1 = load %struct.node*, %struct.node** %left, align 8
11   %cmp1 = icmp eq %struct.node* %1, null
12   call void @CreateNode(%struct.node** %left3, i32 %n)
Block: if.end16
4   %val = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 2
5   %0 = load i32, i32* %val, align 8
7   %cmp = icmp sgt i32 %n, %0
Block: if.end15
4   %val = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 2
5   %0 = load i32, i32* %val, align 8
7   %cmp = icmp sgt i32 %n, %0
15   %3 = load i32, i32* %val6, align 8
16   %cmp7 = icmp slt i32 %n, %3
Block: if.end14
4   %val = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 2
5   %0 = load i32, i32* %val, align 8
7   %cmp = icmp sgt i32 %n, %0
15   %3 = load i32, i32* %val6, align 8
16   %cmp7 = icmp slt i32 %n, %3
18   %right = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
19   %4 = load %struct.node*, %struct.node** %right, align 8
20   %cmp9 = icmp eq %struct.node* %4, null
Block: if.else12
22   %5 = load %struct.node*, %struct.node** %right13, align 8
7   %cmp = icmp sgt i32 %n, %0
23   call void @Insert(i32 %n, %struct.node* %5)
5   %0 = load i32, i32* %val, align 8
15   %3 = load i32, i32* %val6, align 8
4   %val = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 2
16   %cmp7 = icmp slt i32 %n, %3
18   %right = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
19   %4 = load %struct.node*, %struct.node** %right, align 8
20   %cmp9 = icmp eq %struct.node* %4, null
Block: if.then10
21   call void @CreateNode(%struct.node** %right11, i32 %n)
7   %cmp = icmp sgt i32 %n, %0
5   %0 = load i32, i32* %val, align 8
15   %3 = load i32, i32* %val6, align 8
4   %val = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 2
16   %cmp7 = icmp slt i32 %n, %3
18   %right = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
19   %4 = load %struct.node*, %struct.node** %right, align 8
20   %cmp9 = icmp eq %struct.node* %4, null
Block: if.else5.if.end15_crit_edge
4   %val = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 2
5   %0 = load i32, i32* %val, align 8
7   %cmp = icmp sgt i32 %n, %0
15   %3 = load i32, i32* %val6, align 8
16   %cmp7 = icmp slt i32 %n, %3
Block: if.then8
4   %val = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 2
5   %0 = load i32, i32* %val, align 8
7   %cmp = icmp sgt i32 %n, %0
15   %3 = load i32, i32* %val6, align 8
16   %cmp7 = icmp slt i32 %n, %3
18   %right = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
19   %4 = load %struct.node*, %struct.node** %right, align 8
20   %cmp9 = icmp eq %struct.node* %4, null
anticipateIn for each Basic Block 
Block: entry
8   %left3 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 0
8   %left4 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 0
18   %right11 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
18   %right13 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
4   %val6 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 2
Block: if.end
Block: if.else5
18   %right11 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
18   %right13 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
4   %val6 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 2
Block: if.else
8   %left4 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 0
Block: if.then
8   %left3 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 0
8   %left4 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 0
Block: if.then2
8   %left3 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 0
Block: if.end16
Block: if.end15
Block: if.end14
Block: if.else12
18   %right13 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
Block: if.then10
18   %right11 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
Block: if.else5.if.end15_crit_edge
Block: if.then8
18   %right11 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
18   %right13 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
24
available out point of each value number0: 
1: 
2: 
3: 
4: if.then8 if.else5.if.end15_crit_edge if.then10 if.else12 if.end14 if.end15 if.end16 if.then2 if.then if.else if.else5 if.end entry 
5: if.then8 if.else5.if.end15_crit_edge if.then10 if.else12 if.end14 if.end15 if.end16 if.then2 if.then if.else if.else5 if.end entry 
6: 
7: if.then8 if.else5.if.end15_crit_edge if.then10 if.else12 if.end14 if.end15 if.end16 if.then2 if.then if.else if.else5 if.end entry 
8: if.then2 if.then if.else if.end 
9: if.then2 if.then if.else if.end 
10: 
11: if.then2 if.then if.else if.end 
12: if.then2 
13: if.else 
14: if.else 
15: if.then8 if.else5.if.end15_crit_edge if.then10 if.else12 if.end14 if.end15 if.else5 
16: if.then8 if.else5.if.end15_crit_edge if.then10 if.else12 if.end14 if.end15 if.else5 
17: 
18: if.then8 if.then10 if.else12 if.end14 
19: if.then8 if.then10 if.else12 if.end14 
20: if.then8 if.then10 if.else12 if.end14 
21: if.then10 
22: if.else12 
23: if.else12 
antipate in point of each value number0: 
1: 
2: 
3: 
4: if.else5 entry 
5: 
6: 
7: 
8: if.then2 if.then if.else entry 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: if.then8 if.then10 if.else12 if.else5 entry 
19: 
20: 
21: 
22: 
23: 
valunumber: 0
0				0				
0				0				
min cut from 0 to 1
valunumber: 1
0				0				
0				0				
min cut from 0 to 1
valunumber: 2
0				0				
0				0				
min cut from 0 to 1
valunumber: 3
0				0				
0				0				
min cut from 0 to 1
valunumber: 4
0				0				
0				0				
min cut from 0 to 1
valunumber: 5
0				0				
0				0				
min cut from 0 to 1
valunumber: 6
0				0				
0				0				
min cut from 0 to 1
valunumber: 7
0				0				
0				0				
min cut from 0 to 1
valunumber: 8
entry to if.then: 85 5.000000e-01
0				43				0				0				
0				0				0				2147483647				
2147483647				0				0				0				
0				0				0				0				
min cut from 2 to 3
entry - if.then
valunumber: 9
0				0				
0				0				
min cut from 0 to 1
valunumber: 10
0				0				
0				0				
min cut from 0 to 1
valunumber: 11
0				0				
0				0				
min cut from 0 to 1
valunumber: 12
0				0				
0				0				
min cut from 0 to 1
valunumber: 13
0				0				
0				0				
min cut from 0 to 1
valunumber: 14
0				0				
0				0				
min cut from 0 to 1
valunumber: 15
0				0				
0				0				
min cut from 0 to 1
valunumber: 16
0				0				
0				0				
min cut from 0 to 1
valunumber: 17
0				0				
0				0				
min cut from 0 to 1
valunumber: 18
if.else5 to if.then8: 42 5.000000e-01
entry to if.else5: 85 5.000000e-01
0				22				0				0				0				
0				0				0				0				2147483647				
43				0				0				0				0				
0				0				2147483647				0				0				
0				0				0				0				0				
min cut from 3 to 4
if.else5 - if.then8
valunumber: 19
0				0				
0				0				
min cut from 0 to 1
valunumber: 20
0				0				
0				0				
min cut from 0 to 1
valunumber: 21
0				0				
0				0				
min cut from 0 to 1
valunumber: 22
0				0				
0				0				
min cut from 0 to 1
valunumber: 23
0				0				
0				0				
min cut from 0 to 1
insert into if.then8.split
available
  %val = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 2
  %0 = load i32, i32* %val, align 8
  %cmp = icmp sgt i32 %n, %0
  %3 = load i32, i32* %val6, align 8
  %cmp7 = icmp slt i32 %n, %3
18 prepared
try   %right11 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1

if.then8.split:                                   ; preds = %if.else5
  %OptInsert_right11 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
  br label %if.then8

insert into if.then.split
available
  %val = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 2
  %0 = load i32, i32* %val, align 8
  %cmp = icmp sgt i32 %n, %0
8 prepared
try   %left3 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 0

if.then.split:                                    ; preds = %entry
  %OptInsert_left3 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 0
  br label %if.then

if.then.split has dominance frontier:
if.end16 
if.then has dominance frontier:
if.end16 
if.end has dominance frontier:
if.end16 
if.else5 has dominance frontier:
if.end16 
if.end15 has dominance frontier:
if.end16 
if.end14 has dominance frontier:
if.end15 
if.then8 has dominance frontier:
if.end15 
if.else5.if.end15_crit_edge has dominance frontier:
if.end15 
if.then8.split has dominance frontier:
if.end15 
if.then10 has dominance frontier:
if.end14 
if.else12 has dominance frontier:
if.end14 
if.then2 has dominance frontier:
if.end 
if.else has dominance frontier:
if.end 
8 in newValueSet
  %OptInsert_left3 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 0
8 in newDefined
  %OptInsert_left3 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 0
18 in newValueSet
  %OptInsert_right11 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
18 in newDefined
  %OptInsert_right11 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
revNewValue
18:   %OptInsert_right11 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
8:   %OptInsert_left3 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 0
rename: entry
  %val = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 2
  %0 = load i32, i32* %val, align 8
  %val = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 2
  %cmp = icmp sgt i32 %n, %0
  %0 = load i32, i32* %val, align 8
  br i1 %cmp, label %if.then.split, label %if.else5
  %cmp = icmp sgt i32 %n, %0
fill in phi

if.then.split:                                    ; preds = %entry
  %OptInsert_left3 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 0
  br label %if.then

if.else5:                                         ; preds = %entry
  %val6 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 2
  %3 = load i32, i32* %val6, align 8
  %cmp7 = icmp slt i32 %n, %3
  br i1 %cmp7, label %if.then8.split, label %if.else5.if.end15_crit_edge
rename: if.then.split
  %OptInsert_left3 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 0
  br label %if.then
fill in phi

if.then:                                          ; preds = %if.then.split
  %left = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 0
  %1 = load %struct.node*, %struct.node** %left, align 8
  %cmp1 = icmp eq %struct.node* %1, null
  br i1 %cmp1, label %if.then2, label %if.else
rename: if.then
  %left = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 0
  %1 = load %struct.node*, %struct.node** %left, align 8
  %left = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 0
  %cmp1 = icmp eq %struct.node* %1, null
  %1 = load %struct.node*, %struct.node** %OptInsert_left3, align 8
  br i1 %cmp1, label %if.then2, label %if.else
  %cmp1 = icmp eq %struct.node* %1, null
fill in phi

if.then2:                                         ; preds = %if.then
  %left3 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 0
  call void @CreateNode(%struct.node** %left3, i32 %n)
  br label %if.end

if.else:                                          ; preds = %if.then
  %left4 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 0
  %2 = load %struct.node*, %struct.node** %left4, align 8
  call void @Insert(i32 %n, %struct.node* %2)
  br label %if.end
rename: if.then2
  %left3 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 0
  call void @CreateNode(%struct.node** %left3, i32 %n)
  %left3 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 0
  br label %if.end
fill in phi

if.end:                                           ; preds = %if.else, %if.then2
  br label %if.end16
rename: if.end
  br label %if.end16
fill in phi

if.end16:                                         ; preds = %if.end15, %if.end
  ret void
rename: if.else
  %left4 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 0
  %2 = load %struct.node*, %struct.node** %left4, align 8
  %left4 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 0
  call void @Insert(i32 %n, %struct.node* %2)
  %2 = load %struct.node*, %struct.node** %OptInsert_left3, align 8
  br label %if.end
fill in phi

if.end:                                           ; preds = %if.else, %if.then2
  br label %if.end16
rename: if.end16
  ret void
fill in phi
rename: if.else5
  %val6 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 2
  %3 = load i32, i32* %val6, align 8
  %val6 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 2
  %cmp7 = icmp slt i32 %n, %3
  %3 = load i32, i32* %val6, align 8
  br i1 %cmp7, label %if.then8.split, label %if.else5.if.end15_crit_edge
  %cmp7 = icmp slt i32 %n, %3
fill in phi

if.then8.split:                                   ; preds = %if.else5
  %OptInsert_right11 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
  br label %if.then8

if.else5.if.end15_crit_edge:                      ; preds = %if.else5
  br label %if.end15
rename: if.then8.split
  %OptInsert_right11 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
  br label %if.then8
fill in phi

if.then8:                                         ; preds = %if.then8.split
  %right = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
  %4 = load %struct.node*, %struct.node** %right, align 8
  %cmp9 = icmp eq %struct.node* %4, null
  br i1 %cmp9, label %if.then10, label %if.else12
rename: if.then8
  %right = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
  %4 = load %struct.node*, %struct.node** %right, align 8
  %right = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
  %cmp9 = icmp eq %struct.node* %4, null
  %4 = load %struct.node*, %struct.node** %OptInsert_right11, align 8
  br i1 %cmp9, label %if.then10, label %if.else12
  %cmp9 = icmp eq %struct.node* %4, null
fill in phi

if.then10:                                        ; preds = %if.then8
  %right11 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
  call void @CreateNode(%struct.node** %right11, i32 %n)
  br label %if.end14

if.else12:                                        ; preds = %if.then8
  %right13 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
  %5 = load %struct.node*, %struct.node** %right13, align 8
  call void @Insert(i32 %n, %struct.node* %5)
  br label %if.end14
rename: if.then10
  %right11 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
  call void @CreateNode(%struct.node** %right11, i32 %n)
  %right11 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
  br label %if.end14
fill in phi

if.end14:                                         ; preds = %if.else12, %if.then10
  br label %if.end15
rename: if.end14
  br label %if.end15
fill in phi

if.end15:                                         ; preds = %if.else5.if.end15_crit_edge, %if.end14
  br label %if.end16
rename: if.else12
  %right13 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
  %5 = load %struct.node*, %struct.node** %right13, align 8
  %right13 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
  call void @Insert(i32 %n, %struct.node* %5)
  %5 = load %struct.node*, %struct.node** %OptInsert_right11, align 8
  br label %if.end14
fill in phi

if.end14:                                         ; preds = %if.else12, %if.then10
  br label %if.end15
rename: if.end15
  br label %if.end16
fill in phi

if.end16:                                         ; preds = %if.end15, %if.end
  ret void
rename: if.else5.if.end15_crit_edge
  br label %if.end15
fill in phi

if.end15:                                         ; preds = %if.else5.if.end15_crit_edge, %if.end14
  br label %if.end16

entry:
  %val = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 2
  %0 = load i32, i32* %val, align 8
  %cmp = icmp sgt i32 %n, %0
  br i1 %cmp, label %if.then.split, label %if.else5


if.then.split:                                    ; preds = %entry
  %OptInsert_left3 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 0
  br label %if.then


if.then:                                          ; preds = %if.then.split
  %left = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 0
  %1 = load %struct.node*, %struct.node** %OptInsert_left3, align 8
  %cmp1 = icmp eq %struct.node* %1, null
  br i1 %cmp1, label %if.then2, label %if.else


if.then2:                                         ; preds = %if.then
  %left3 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 0
  call void @CreateNode(%struct.node** %OptInsert_left3, i32 %n)
  br label %if.end


if.else:                                          ; preds = %if.then
  %left4 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 0
  %2 = load %struct.node*, %struct.node** %OptInsert_left3, align 8
  call void @Insert(i32 %n, %struct.node* %2)
  br label %if.end


if.end:                                           ; preds = %if.else, %if.then2
  br label %if.end16


if.else5:                                         ; preds = %entry
  %val6 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 2
  %3 = load i32, i32* %val6, align 8
  %cmp7 = icmp slt i32 %n, %3
  br i1 %cmp7, label %if.then8.split, label %if.else5.if.end15_crit_edge


if.else5.if.end15_crit_edge:                      ; preds = %if.else5
  br label %if.end15


if.then8.split:                                   ; preds = %if.else5
  %OptInsert_right11 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
  br label %if.then8


if.then8:                                         ; preds = %if.then8.split
  %right = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
  %4 = load %struct.node*, %struct.node** %OptInsert_right11, align 8
  %cmp9 = icmp eq %struct.node* %4, null
  br i1 %cmp9, label %if.then10, label %if.else12


if.then10:                                        ; preds = %if.then8
  %right11 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
  call void @CreateNode(%struct.node** %OptInsert_right11, i32 %n)
  br label %if.end14


if.else12:                                        ; preds = %if.then8
  %right13 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
  %5 = load %struct.node*, %struct.node** %OptInsert_right11, align 8
  call void @Insert(i32 %n, %struct.node* %5)
  br label %if.end14


if.end14:                                         ; preds = %if.else12, %if.then10
  br label %if.end15


if.end15:                                         ; preds = %if.else5.if.end15_crit_edge, %if.end14
  br label %if.end16


if.end16:                                         ; preds = %if.end15, %if.end
  ret void

entry
  %val = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 2
  %0 = load i32, i32* %val, align 8
  %cmp = icmp sgt i32 %n, %0
  br i1 %cmp, label %if.then.split, label %if.else5
if.then.split
  %OptInsert_left3 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 0
  br label %if.then
if.then
  %left = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 0
  %1 = load %struct.node*, %struct.node** %OptInsert_left3, align 8
  %cmp1 = icmp eq %struct.node* %1, null
  br i1 %cmp1, label %if.then2, label %if.else
if.then2
  %left3 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 0
  call void @CreateNode(%struct.node** %OptInsert_left3, i32 %n)
  br label %if.end
if.else
  %left4 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 0
  %2 = load %struct.node*, %struct.node** %OptInsert_left3, align 8
  call void @Insert(i32 %n, %struct.node* %2)
  br label %if.end
if.end
  br label %if.end16
if.else5
  %val6 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 2
  %3 = load i32, i32* %val6, align 8
  %cmp7 = icmp slt i32 %n, %3
  br i1 %cmp7, label %if.then8.split, label %if.else5.if.end15_crit_edge
if.else5.if.end15_crit_edge
  br label %if.end15
if.then8.split
  %OptInsert_right11 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
  br label %if.then8
if.then8
  %right = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
  %4 = load %struct.node*, %struct.node** %OptInsert_right11, align 8
  %cmp9 = icmp eq %struct.node* %4, null
  br i1 %cmp9, label %if.then10, label %if.else12
if.then10
  %right11 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
  call void @CreateNode(%struct.node** %OptInsert_right11, i32 %n)
  br label %if.end14
if.else12
  %right13 = getelementptr inbounds %struct.node, %struct.node* %t, i32 0, i32 1
  %5 = load %struct.node*, %struct.node** %OptInsert_right11, align 8
  call void @Insert(i32 %n, %struct.node* %5)
  br label %if.end14
if.end14
  br label %if.end15
if.end15
  br label %if.end16
if.end16
  ret void
begin
changed
if.end24
if.end23
if.then14
land.end21
new
  %11 = phi i1 [ false, %if.else15.land.end21_crit_edge ], [ %tobool20, %land.rhs19 ]
land.rhs19
new
  %tobool20 = icmp ne i32 %result.1, 0
  %result.1 = phi i32 [ %result.0, %if.end ], [ 1, %entry.if.end7_crit_edge ]
if.else15.land.end21_crit_edge
new
i1 false
if.else15
new
  %tobool20 = icmp ne i32 %result.1, 0
  %result.1 = phi i32 [ %result.0, %if.end ], [ 1, %entry.if.end7_crit_edge ]
i1 false
  %right16 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 1
if.then9
new
  %val12 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 2
  %right16 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 1
  %result.1 = phi i32 [ %result.0, %if.end ], [ 1, %entry.if.end7_crit_edge ]
i1 false
  %tobool20 = icmp ne i32 %result.1, 0
if.end7.if.end24_crit_edge
if.end7
new
  %val12 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 2
  %right16 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 1
  %result.1 = phi i32 [ %result.0, %if.end ], [ 1, %entry.if.end7_crit_edge ]
i1 false
if.end
new
  %val12 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 2
  %right16 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 1
  %result.0 = phi i32 [ 0, %if.then4 ], [ %land.ext, %land.end ]
i1 false
if.then4
new
  %val12 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 2
  %right16 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 1
i32 0
i1 false
land.end
new
  %val12 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 2
  %right16 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 1
i1 false
  %5 = phi i1 [ false, %if.else.land.end_crit_edge ], [ %tobool6, %land.rhs ]
land.rhs
new
  %val12 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 2
  %right16 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 1
i1 false
  %tobool6 = icmp ne i32 1, 0
if.else.land.end_crit_edge
new
  %val12 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 2
  %right16 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 1
i1 false
if.else
new
  %val12 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 2
  %right16 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 1
i1 false
  %tobool6 = icmp ne i32 1, 0
  %left5 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 0
if.then
new
  %val12 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 2
  %right16 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 1
i32 0
i1 false
  %left5 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 0
  %tobool6 = icmp ne i32 1, 0
entry.if.end7_crit_edge
new
  %val12 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 2
  %right16 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 1
i32 1
i1 false
entry
new
  %val12 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 2
  %right16 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 1
i32 0
i1 false
  %left5 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 0
i32 1
  %tobool6 = icmp ne i32 1, 0
changed
land.end21
  %11 = phi i1 [ false, %if.else15.land.end21_crit_edge ], [ %tobool20, %land.rhs19 ]
land.rhs19
  %tobool20 = icmp ne i32 %result.1, 0
  %result.1 = phi i32 [ %result.0, %if.end ], [ 1, %entry.if.end7_crit_edge ]
if.else15.land.end21_crit_edge
i1 false
if.else15
  %tobool20 = icmp ne i32 %result.1, 0
  %result.1 = phi i32 [ %result.0, %if.end ], [ 1, %entry.if.end7_crit_edge ]
i1 false
  %right16 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 1
if.then9
  %val12 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 2
  %right16 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 1
  %result.1 = phi i32 [ %result.0, %if.end ], [ 1, %entry.if.end7_crit_edge ]
i1 false
  %tobool20 = icmp ne i32 %result.1, 0
if.end7
  %val12 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 2
  %right16 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 1
  %result.1 = phi i32 [ %result.0, %if.end ], [ 1, %entry.if.end7_crit_edge ]
i1 false
if.end
  %val12 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 2
  %right16 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 1
  %result.0 = phi i32 [ 0, %if.then4 ], [ %land.ext, %land.end ]
i1 false
if.then4
  %val12 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 2
  %right16 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 1
i32 0
i1 false
land.end
  %val12 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 2
  %right16 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 1
i1 false
  %5 = phi i1 [ false, %if.else.land.end_crit_edge ], [ %tobool6, %land.rhs ]
land.rhs
  %val12 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 2
  %right16 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 1
i1 false
  %tobool6 = icmp ne i32 1, 0
if.else.land.end_crit_edge
  %val12 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 2
  %right16 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 1
i1 false
if.else
  %val12 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 2
  %right16 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 1
i1 false
  %tobool6 = icmp ne i32 1, 0
  %left5 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 0
if.then
  %val12 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 2
  %right16 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 1
i32 0
i1 false
  %left5 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 0
  %tobool6 = icmp ne i32 1, 0
entry.if.end7_crit_edge
  %val12 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 2
  %right16 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 1
i32 1
i1 false
entry
  %val12 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 2
  %right16 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 1
i32 0
i1 false
  %left5 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 0
i32 1
  %tobool6 = icmp ne i32 1, 0
avaiableOut for each Basic Block 
Block: land.rhs
10   %2 = load i32, i32* %val, align 8
11   %val2 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 2
4   %0 = load %struct.node*, %struct.node** %left, align 8
9   %val = getelementptr inbounds %struct.node, %struct.node* %1, i32 0, i32 2
12   %3 = load i32, i32* %val2, align 8
13   %cmp3 = icmp sle i32 %2, %3
3   %left = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 0
15   %4 = load %struct.node*, %struct.node** %left5, align 8
16   %call = call i32 @Checktree(%struct.node* %4)
7   %1 = load %struct.node*, %struct.node** %left1, align 8
19   %tobool6 = icmp ne i32 1, 0
17   %tobool = icmp ne i32 %call, 0
6   %cmp = icmp ne %struct.node* %0, null
Block: land.end
10   %2 = load i32, i32* %val, align 8
11   %val2 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 2
21   %land.ext = zext i1 %5 to i32
4   %0 = load %struct.node*, %struct.node** %left, align 8
9   %val = getelementptr inbounds %struct.node, %struct.node* %1, i32 0, i32 2
12   %3 = load i32, i32* %val2, align 8
13   %cmp3 = icmp sle i32 %2, %3
3   %left = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 0
15   %4 = load %struct.node*, %struct.node** %left5, align 8
16   %call = call i32 @Checktree(%struct.node* %4)
20   %5 = phi i1 [ false, %if.else.land.end_crit_edge ], [ %tobool6, %land.rhs ]
7   %1 = load %struct.node*, %struct.node** %left1, align 8
17   %tobool = icmp ne i32 %call, 0
6   %cmp = icmp ne %struct.node* %0, null
Block: if.else.land.end_crit_edge
10   %2 = load i32, i32* %val, align 8
11   %val2 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 2
4   %0 = load %struct.node*, %struct.node** %left, align 8
9   %val = getelementptr inbounds %struct.node, %struct.node* %1, i32 0, i32 2
12   %3 = load i32, i32* %val2, align 8
13   %cmp3 = icmp sle i32 %2, %3
3   %left = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 0
15   %4 = load %struct.node*, %struct.node** %left5, align 8
16   %call = call i32 @Checktree(%struct.node* %4)
7   %1 = load %struct.node*, %struct.node** %left1, align 8
17   %tobool = icmp ne i32 %call, 0
6   %cmp = icmp ne %struct.node* %0, null
Block: if.end
14   %result.0 = phi i32 [ 0, %if.then4 ], [ %land.ext, %land.end ]
10   %2 = load i32, i32* %val, align 8
11   %val2 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 2
4   %0 = load %struct.node*, %struct.node** %left, align 8
9   %val = getelementptr inbounds %struct.node, %struct.node* %1, i32 0, i32 2
12   %3 = load i32, i32* %val2, align 8
13   %cmp3 = icmp sle i32 %2, %3
3   %left = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 0
7   %1 = load %struct.node*, %struct.node** %left1, align 8
6   %cmp = icmp ne %struct.node* %0, null
Block: if.end24
3   %left = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 0
4   %0 = load %struct.node*, %struct.node** %left, align 8
6   %cmp = icmp ne %struct.node* %0, null
22   %result.1 = phi i32 [ %result.0, %if.end ], [ 1, %entry.if.end7_crit_edge ]
23   %right = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 1
24   %6 = load %struct.node*, %struct.node** %right, align 8
25   %cmp8 = icmp ne %struct.node* %6, null
38   %result.3 = phi i32 [ %result.2, %if.end23 ], [ %result.1, %if.end7.if.end24_crit_edge ]
Block: if.then4
10   %2 = load i32, i32* %val, align 8
11   %val2 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 2
4   %0 = load %struct.node*, %struct.node** %left, align 8
9   %val = getelementptr inbounds %struct.node, %struct.node* %1, i32 0, i32 2
12   %3 = load i32, i32* %val2, align 8
13   %cmp3 = icmp sle i32 %2, %3
3   %left = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 0
7   %1 = load %struct.node*, %struct.node** %left1, align 8
6   %cmp = icmp ne %struct.node* %0, null
Block: if.else
10   %2 = load i32, i32* %val, align 8
11   %val2 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 2
4   %0 = load %struct.node*, %struct.node** %left, align 8
9   %val = getelementptr inbounds %struct.node, %struct.node* %1, i32 0, i32 2
12   %3 = load i32, i32* %val2, align 8
13   %cmp3 = icmp sle i32 %2, %3
3   %left = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 0
15   %4 = load %struct.node*, %struct.node** %left5, align 8
16   %call = call i32 @Checktree(%struct.node* %4)
7   %1 = load %struct.node*, %struct.node** %left1, align 8
17   %tobool = icmp ne i32 %call, 0
6   %cmp = icmp ne %struct.node* %0, null
Block: if.else15
30   %cmp13 = icmp sge i32 %8, %9
29   %9 = load i32, i32* %val12, align 8
11   %val12 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 2
4   %0 = load %struct.node*, %struct.node** %left, align 8
23   %right = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 1
22   %result.1 = phi i32 [ %result.0, %if.end ], [ 1, %entry.if.end7_crit_edge ]
3   %left = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 0
34   %tobool18 = icmp ne i32 %call17, 0
25   %cmp8 = icmp ne %struct.node* %6, null
33   %call17 = call i32 @Checktree(%struct.node* %10)
32   %10 = load %struct.node*, %struct.node** %right16, align 8
24   %6 = load %struct.node*, %struct.node** %right, align 8
28   %8 = load i32, i32* %val11, align 8
27   %val11 = getelementptr inbounds %struct.node, %struct.node* %7, i32 0, i32 2
6   %cmp = icmp ne %struct.node* %0, null
26   %7 = load %struct.node*, %struct.node** %right10, align 8
Block: land.rhs19
30   %cmp13 = icmp sge i32 %8, %9
29   %9 = load i32, i32* %val12, align 8
11   %val12 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 2
4   %0 = load %struct.node*, %struct.node** %left, align 8
23   %right = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 1
22   %result.1 = phi i32 [ %result.0, %if.end ], [ 1, %entry.if.end7_crit_edge ]
3   %left = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 0
34   %tobool18 = icmp ne i32 %call17, 0
25   %cmp8 = icmp ne %struct.node* %6, null
33   %call17 = call i32 @Checktree(%struct.node* %10)
32   %10 = load %struct.node*, %struct.node** %right16, align 8
24   %6 = load %struct.node*, %struct.node** %right, align 8
28   %8 = load i32, i32* %val11, align 8
27   %val11 = getelementptr inbounds %struct.node, %struct.node* %7, i32 0, i32 2
6   %cmp = icmp ne %struct.node* %0, null
26   %7 = load %struct.node*, %struct.node** %right10, align 8
35   %tobool20 = icmp ne i32 %result.1, 0
Block: entry
3   %left = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 0
4   %0 = load %struct.node*, %struct.node** %left, align 8
6   %cmp = icmp ne %struct.node* %0, null
Block: land.end21
30   %cmp13 = icmp sge i32 %8, %9
29   %9 = load i32, i32* %val12, align 8
11   %val12 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 2
4   %0 = load %struct.node*, %struct.node** %left, align 8
37   %land.ext22 = zext i1 %11 to i32
23   %right = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 1
22   %result.1 = phi i32 [ %result.0, %if.end ], [ 1, %entry.if.end7_crit_edge ]
3   %left = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 0
34   %tobool18 = icmp ne i32 %call17, 0
25   %cmp8 = icmp ne %struct.node* %6, null
33   %call17 = call i32 @Checktree(%struct.node* %10)
32   %10 = load %struct.node*, %struct.node** %right16, align 8
24   %6 = load %struct.node*, %struct.node** %right, align 8
28   %8 = load i32, i32* %val11, align 8
27   %val11 = getelementptr inbounds %struct.node, %struct.node* %7, i32 0, i32 2
36   %11 = phi i1 [ false, %if.else15.land.end21_crit_edge ], [ %tobool20, %land.rhs19 ]
6   %cmp = icmp ne %struct.node* %0, null
26   %7 = load %struct.node*, %struct.node** %right10, align 8
Block: entry.if.end7_crit_edge
3   %left = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 0
4   %0 = load %struct.node*, %struct.node** %left, align 8
6   %cmp = icmp ne %struct.node* %0, null
Block: if.end23
30   %cmp13 = icmp sge i32 %8, %9
29   %9 = load i32, i32* %val12, align 8
11   %val12 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 2
4   %0 = load %struct.node*, %struct.node** %left, align 8
23   %right = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 1
31   %result.2 = phi i32 [ 0, %if.then14 ], [ %land.ext22, %land.end21 ]
22   %result.1 = phi i32 [ %result.0, %if.end ], [ 1, %entry.if.end7_crit_edge ]
3   %left = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 0
25   %cmp8 = icmp ne %struct.node* %6, null
24   %6 = load %struct.node*, %struct.node** %right, align 8
28   %8 = load i32, i32* %val11, align 8
27   %val11 = getelementptr inbounds %struct.node, %struct.node* %7, i32 0, i32 2
6   %cmp = icmp ne %struct.node* %0, null
26   %7 = load %struct.node*, %struct.node** %right10, align 8
Block: if.end7
3   %left = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 0
4   %0 = load %struct.node*, %struct.node** %left, align 8
6   %cmp = icmp ne %struct.node* %0, null
22   %result.1 = phi i32 [ %result.0, %if.end ], [ 1, %entry.if.end7_crit_edge ]
23   %right = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 1
24   %6 = load %struct.node*, %struct.node** %right, align 8
25   %cmp8 = icmp ne %struct.node* %6, null
Block: if.end7.if.end24_crit_edge
3   %left = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 0
4   %0 = load %struct.node*, %struct.node** %left, align 8
6   %cmp = icmp ne %struct.node* %0, null
22   %result.1 = phi i32 [ %result.0, %if.end ], [ 1, %entry.if.end7_crit_edge ]
23   %right = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 1
24   %6 = load %struct.node*, %struct.node** %right, align 8
25   %cmp8 = icmp ne %struct.node* %6, null
Block: if.then9
30   %cmp13 = icmp sge i32 %8, %9
29   %9 = load i32, i32* %val12, align 8
11   %val12 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 2
4   %0 = load %struct.node*, %struct.node** %left, align 8
23   %right = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 1
22   %result.1 = phi i32 [ %result.0, %if.end ], [ 1, %entry.if.end7_crit_edge ]
3   %left = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 0
25   %cmp8 = icmp ne %struct.node* %6, null
24   %6 = load %struct.node*, %struct.node** %right, align 8
28   %8 = load i32, i32* %val11, align 8
27   %val11 = getelementptr inbounds %struct.node, %struct.node* %7, i32 0, i32 2
6   %cmp = icmp ne %struct.node* %0, null
26   %7 = load %struct.node*, %struct.node** %right10, align 8
Block: if.then
10   %2 = load i32, i32* %val, align 8
11   %val2 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 2
4   %0 = load %struct.node*, %struct.node** %left, align 8
9   %val = getelementptr inbounds %struct.node, %struct.node* %1, i32 0, i32 2
12   %3 = load i32, i32* %val2, align 8
13   %cmp3 = icmp sle i32 %2, %3
3   %left = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 0
7   %1 = load %struct.node*, %struct.node** %left1, align 8
6   %cmp = icmp ne %struct.node* %0, null
Block: if.else15.land.end21_crit_edge
30   %cmp13 = icmp sge i32 %8, %9
29   %9 = load i32, i32* %val12, align 8
11   %val12 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 2
4   %0 = load %struct.node*, %struct.node** %left, align 8
23   %right = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 1
22   %result.1 = phi i32 [ %result.0, %if.end ], [ 1, %entry.if.end7_crit_edge ]
3   %left = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 0
34   %tobool18 = icmp ne i32 %call17, 0
25   %cmp8 = icmp ne %struct.node* %6, null
33   %call17 = call i32 @Checktree(%struct.node* %10)
32   %10 = load %struct.node*, %struct.node** %right16, align 8
24   %6 = load %struct.node*, %struct.node** %right, align 8
28   %8 = load i32, i32* %val11, align 8
27   %val11 = getelementptr inbounds %struct.node, %struct.node* %7, i32 0, i32 2
6   %cmp = icmp ne %struct.node* %0, null
26   %7 = load %struct.node*, %struct.node** %right10, align 8
Block: if.then14
30   %cmp13 = icmp sge i32 %8, %9
29   %9 = load i32, i32* %val12, align 8
11   %val12 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 2
4   %0 = load %struct.node*, %struct.node** %left, align 8
23   %right = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 1
22   %result.1 = phi i32 [ %result.0, %if.end ], [ 1, %entry.if.end7_crit_edge ]
3   %left = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 0
25   %cmp8 = icmp ne %struct.node* %6, null
24   %6 = load %struct.node*, %struct.node** %right, align 8
28   %8 = load i32, i32* %val11, align 8
27   %val11 = getelementptr inbounds %struct.node, %struct.node* %7, i32 0, i32 2
6   %cmp = icmp ne %struct.node* %0, null
26   %7 = load %struct.node*, %struct.node** %right10, align 8
anticipateIn for each Basic Block 
Block: land.rhs
23   %right16 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 1
11   %val12 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 2
39 i1 false
19   %tobool6 = icmp ne i32 1, 0
Block: land.end
23   %right16 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 1
11   %val12 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 2
39 i1 false
20   %5 = phi i1 [ false, %if.else.land.end_crit_edge ], [ %tobool6, %land.rhs ]
Block: if.else.land.end_crit_edge
23   %right16 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 1
11   %val12 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 2
39 i1 false
Block: if.end
23   %right16 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 1
14   %result.0 = phi i32 [ 0, %if.then4 ], [ %land.ext, %land.end ]
11   %val12 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 2
39 i1 false
Block: if.end24
Block: if.then4
23   %right16 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 1
2 i32 0
11   %val12 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 2
39 i1 false
Block: if.else
23   %right16 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 1
11   %val12 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 2
39 i1 false
19   %tobool6 = icmp ne i32 1, 0
3   %left5 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 0
Block: if.else15
35   %tobool20 = icmp ne i32 %result.1, 0
22   %result.1 = phi i32 [ %result.0, %if.end ], [ 1, %entry.if.end7_crit_edge ]
39 i1 false
23   %right16 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 1
Block: land.rhs19
35   %tobool20 = icmp ne i32 %result.1, 0
22   %result.1 = phi i32 [ %result.0, %if.end ], [ 1, %entry.if.end7_crit_edge ]
Block: entry
23   %right16 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 1
19   %tobool6 = icmp ne i32 1, 0
2 i32 0
11   %val12 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 2
39 i1 false
3   %left5 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 0
18 i32 1
Block: land.end21
36   %11 = phi i1 [ false, %if.else15.land.end21_crit_edge ], [ %tobool20, %land.rhs19 ]
Block: entry.if.end7_crit_edge
23   %right16 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 1
18 i32 1
11   %val12 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 2
39 i1 false
Block: if.end23
Block: if.end7
23   %right16 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 1
22   %result.1 = phi i32 [ %result.0, %if.end ], [ 1, %entry.if.end7_crit_edge ]
11   %val12 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 2
39 i1 false
Block: if.end7.if.end24_crit_edge
Block: if.then9
23   %right16 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 1
22   %result.1 = phi i32 [ %result.0, %if.end ], [ 1, %entry.if.end7_crit_edge ]
11   %val12 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 2
35   %tobool20 = icmp ne i32 %result.1, 0
39 i1 false
Block: if.then
23   %right16 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 1
19   %tobool6 = icmp ne i32 1, 0
2 i32 0
11   %val12 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 2
39 i1 false
3   %left5 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 0
Block: if.else15.land.end21_crit_edge
39 i1 false
Block: if.then14
40
available out point of each value number0: 
1: 
2: 
3: if.then14 if.then9 if.end7.if.end24_crit_edge if.then land.rhs land.end if.else.land.end_crit_edge if.else15.land.end21_crit_edge entry if.end if.end24 if.then4 if.else if.else15 land.rhs19 land.end21 if.end7 entry.if.end7_crit_edge if.end23 
4: if.then14 if.then9 if.end7.if.end24_crit_edge if.then land.rhs land.end if.else.land.end_crit_edge if.else15.land.end21_crit_edge entry if.end if.end24 if.then4 if.else if.else15 land.rhs19 land.end21 if.end7 entry.if.end7_crit_edge if.end23 
5: 
6: if.then14 if.then9 if.end7.if.end24_crit_edge if.then land.rhs land.end if.else.land.end_crit_edge if.else15.land.end21_crit_edge entry if.end if.end24 if.then4 if.else if.else15 land.rhs19 land.end21 if.end7 entry.if.end7_crit_edge if.end23 
7: if.else if.then4 if.end if.else.land.end_crit_edge if.then land.end land.rhs 
8: 
9: if.else if.then4 if.end if.else.land.end_crit_edge if.then land.end land.rhs 
10: if.else if.then4 if.end if.else.land.end_crit_edge if.then land.end land.rhs 
11: if.then14 land.end land.rhs if.then if.else.land.end_crit_edge if.then9 if.end if.then4 if.else if.else15 land.rhs19 if.else15.land.end21_crit_edge land.end21 if.end23 
12: if.else if.then4 if.end if.else.land.end_crit_edge if.then land.end land.rhs 
13: if.else if.then4 if.end if.else.land.end_crit_edge if.then land.end land.rhs 
14: if.end 
15: if.else if.else.land.end_crit_edge land.end land.rhs 
16: if.else if.else.land.end_crit_edge land.end land.rhs 
17: if.else if.else.land.end_crit_edge land.end land.rhs 
18: 
19: land.rhs 
20: land.end 
21: land.end 
22: if.then14 if.then9 if.end7.if.end24_crit_edge if.end7 if.end23 land.end21 if.else15.land.end21_crit_edge land.rhs19 if.else15 if.end24 
23: if.then14 if.then9 if.end7.if.end24_crit_edge if.end7 if.end23 land.end21 if.else15.land.end21_crit_edge land.rhs19 if.else15 if.end24 
24: if.then14 if.then9 if.end7.if.end24_crit_edge if.end7 if.end23 land.end21 if.else15.land.end21_crit_edge land.rhs19 if.else15 if.end24 
25: if.then14 if.then9 if.end7.if.end24_crit_edge if.end7 if.end23 land.end21 if.else15.land.end21_crit_edge land.rhs19 if.else15 if.end24 
26: if.then14 if.then9 if.end23 land.end21 if.else15.land.end21_crit_edge land.rhs19 if.else15 
27: if.then14 if.then9 if.end23 land.end21 if.else15.land.end21_crit_edge land.rhs19 if.else15 
28: if.then14 if.then9 if.end23 land.end21 if.else15.land.end21_crit_edge land.rhs19 if.else15 
29: if.then14 if.then9 if.end23 land.end21 if.else15.land.end21_crit_edge land.rhs19 if.else15 
30: if.then14 if.then9 if.end23 land.end21 if.else15.land.end21_crit_edge land.rhs19 if.else15 
31: if.end23 
32: land.end21 if.else15.land.end21_crit_edge land.rhs19 if.else15 
33: land.end21 if.else15.land.end21_crit_edge land.rhs19 if.else15 
34: land.end21 if.else15.land.end21_crit_edge land.rhs19 if.else15 
35: land.rhs19 
36: land.end21 
37: land.end21 
38: if.end24 
39: 
antipate in point of each value number0: 
1: 
2: if.then entry if.then4 
3: if.then entry if.else 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: if.end7 entry.if.end7_crit_edge if.else if.then4 if.end if.then9 entry if.else.land.end_crit_edge if.then land.end land.rhs 
12: 
13: 
14: if.end 
15: 
16: 
17: 
18: entry.if.end7_crit_edge entry 
19: if.then entry if.else land.rhs 
20: land.end 
21: 
22: if.then9 if.end7 land.rhs19 if.else15 
23: if.end7 entry.if.end7_crit_edge if.else15 if.else if.then4 if.end if.then9 entry if.else.land.end_crit_edge if.then land.end land.rhs 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: if.then9 land.rhs19 if.else15 
36: land.end21 
37: 
38: 
39: if.else15.land.end21_crit_edge if.end7 entry.if.end7_crit_edge if.else15 if.else if.then4 if.end if.then9 entry if.else.land.end_crit_edge if.then land.end land.rhs 
valunumber: 0
0				0				
0				0				
min cut from 0 to 1
valunumber: 1
0				0				
0				0				
min cut from 0 to 1
valunumber: 2
entry to if.then: 68 6.250000e-01
if.then to if.then4: 42 5.000000e-01
0				43				0				0				0				
0				0				22				0				0				
0				0				0				0				2147483647				
2147483647				0				0				0				0				
0				0				0				0				0				
min cut from 3 to 4
if.then - if.then4
valunumber: 3
0				0				
0				0				
min cut from 0 to 1
valunumber: 4
0				0				
0				0				
min cut from 0 to 1
valunumber: 5
0				0				
0				0				
min cut from 0 to 1
valunumber: 6
0				0				
0				0				
min cut from 0 to 1
valunumber: 7
0				0				
0				0				
min cut from 0 to 1
valunumber: 8
0				0				
0				0				
min cut from 0 to 1
valunumber: 9
0				0				
0				0				
min cut from 0 to 1
valunumber: 10
0				0				
0				0				
min cut from 0 to 1
valunumber: 11
entry.if.end7_crit_edge to if.end7: 25 1.000000e+00
entry to entry.if.end7_crit_edge: 68 3.750000e-01
if.end7 to if.then9: 68 6.250000e-01
entry to if.then: 68 6.250000e-01
0				26				0				0				0				0				0				
0				0				0				43				0				0				0				
26				0				0				0				43				0				0				
0				0				0				0				0				0				2147483647				
0				0				0				0				0				0				2147483647				
0				0				2147483647				0				0				0				0				
0				0				0				0				0				0				0				
min cut from 5 to 6
entry - entry.if.end7_crit_edge
entry - if.then
valunumber: 12
0				0				
0				0				
min cut from 0 to 1
valunumber: 13
0				0				
0				0				
min cut from 0 to 1
valunumber: 14
land.end to if.end: 21 1.000000e+00
if.then4 to if.end: 21 1.000000e+00
0				22				0				0				0				
0				0				0				0				2147483647				
0				22				0				0				0				
2147483647				0				2147483647				0				0				
0				0				0				0				0				
min cut from 3 to 4
land.end - if.end
if.then4 - if.end
valunumber: 15
0				0				
0				0				
min cut from 0 to 1
valunumber: 16
0				0				
0				0				
min cut from 0 to 1
valunumber: 17
0				0				
0				0				
min cut from 0 to 1
valunumber: 18
entry to entry.if.end7_crit_edge: 68 3.750000e-01
0				26				0				0				
0				0				0				2147483647				
2147483647				0				0				0				
0				0				0				0				
min cut from 2 to 3
entry - entry.if.end7_crit_edge
valunumber: 19
entry to if.then: 68 6.250000e-01
if.then to if.else: 42 5.000000e-01
if.else to land.rhs: 21 6.250000e-01
0				43				0				0				0				0				
0				0				22				0				0				0				
0				0				0				14				0				0				
0				0				0				0				0				2147483647				
2147483647				0				0				0				0				0				
0				0				0				0				0				0				
min cut from 4 to 5
if.else - land.rhs
valunumber: 20
if.else.land.end_crit_edge to land.end: 8 1.000000e+00
land.rhs to land.end: 13 1.000000e+00
0				9				0				0				0				
0				0				0				0				2147483647				
0				14				0				0				0				
2147483647				0				2147483647				0				0				
0				0				0				0				0				
min cut from 3 to 4
if.else.land.end_crit_edge - land.end
land.rhs - land.end
valunumber: 21
0				0				
0				0				
min cut from 0 to 1
valunumber: 22
entry.if.end7_crit_edge to if.end7: 25 1.000000e+00
if.end to if.end7: 42 1.000000e+00
0				26				0				0				0				
0				0				0				0				2147483647				
0				43				0				0				0				
2147483647				0				2147483647				0				0				
0				0				0				0				0				
min cut from 3 to 4
entry.if.end7_crit_edge - if.end7
if.end - if.end7
valunumber: 23
entry.if.end7_crit_edge to if.end7: 25 1.000000e+00
if.end to if.end7: 42 1.000000e+00
entry to entry.if.end7_crit_edge: 68 3.750000e-01
if.then to if.else: 42 5.000000e-01
if.then to if.then4: 42 5.000000e-01
land.end to if.end: 21 1.000000e+00
if.then4 to if.end: 21 1.000000e+00
if.else to if.else.land.end_crit_edge: 21 3.750000e-01
entry to if.then: 68 6.250000e-01
if.else.land.end_crit_edge to land.end: 8 1.000000e+00
land.rhs to land.end: 13 1.000000e+00
if.else to land.rhs: 21 6.250000e-01
0				26				0				0				0				0				0				0				0				0				0				0				
0				0				0				0				0				0				0				0				0				0				0				2147483647				
0				43				0				0				0				0				0				0				0				0				0				0				
26				0				0				0				43				0				0				0				0				0				0				0				
0				0				0				0				0				22				22				0				0				0				0				0				
0				0				0				0				0				0				0				0				8				14				0				0				
0				0				22				0				0				0				0				0				0				0				0				0				
0				0				22				0				0				0				0				0				0				0				0				0				
0				0				0				0				0				0				0				9				0				0				0				0				
0				0				0				0				0				0				0				14				0				0				0				0				
0				0				0				2147483647				0				0				0				0				0				0				0				0				
0				0				0				0				0				0				0				0				0				0				0				0				
min cut from 10 to 11
entry - entry.if.end7_crit_edge
entry - if.then
valunumber: 24
0				0				
0				0				
min cut from 0 to 1
valunumber: 25
0				0				
0				0				
min cut from 0 to 1
valunumber: 26
0				0				
0				0				
min cut from 0 to 1
valunumber: 27
0				0				
0				0				
min cut from 0 to 1
valunumber: 28
0				0				
0				0				
min cut from 0 to 1
valunumber: 29
0				0				
0				0				
min cut from 0 to 1
valunumber: 30
0				0				
0				0				
min cut from 0 to 1
valunumber: 31
0				0				
0				0				
min cut from 0 to 1
valunumber: 32
0				0				
0				0				
min cut from 0 to 1
valunumber: 33
0				0				
0				0				
min cut from 0 to 1
valunumber: 34
0				0				
0				0				
min cut from 0 to 1
valunumber: 35
if.end7 to if.then9: 68 6.250000e-01
if.else15 to land.rhs19: 21 6.250000e-01
if.then9 to if.else15: 42 5.000000e-01
0				43				0				0				0				0				
0				0				22				0				0				0				
0				0				0				14				0				0				
0				0				0				0				0				2147483647				
2147483647				0				0				0				0				0				
0				0				0				0				0				0				
min cut from 4 to 5
if.else15 - land.rhs19
valunumber: 36
if.else15.land.end21_crit_edge to land.end21: 8 1.000000e+00
land.rhs19 to land.end21: 13 1.000000e+00
0				9				0				0				0				
0				0				0				0				2147483647				
0				14				0				0				0				
2147483647				0				2147483647				0				0				
0				0				0				0				0				
min cut from 3 to 4
if.else15.land.end21_crit_edge - land.end21
land.rhs19 - land.end21
valunumber: 37
0				0				
0				0				
min cut from 0 to 1
valunumber: 38
0				0				
0				0				
min cut from 0 to 1
valunumber: 39
if.else15 to if.else15.land.end21_crit_edge: 21 3.750000e-01
entry.if.end7_crit_edge to if.end7: 25 1.000000e+00
if.end to if.end7: 42 1.000000e+00
entry to entry.if.end7_crit_edge: 68 3.750000e-01
if.then9 to if.else15: 42 5.000000e-01
if.then to if.else: 42 5.000000e-01
if.then to if.then4: 42 5.000000e-01
land.end to if.end: 21 1.000000e+00
if.then4 to if.end: 21 1.000000e+00
if.end7 to if.then9: 68 6.250000e-01
if.else to if.else.land.end_crit_edge: 21 3.750000e-01
entry to if.then: 68 6.250000e-01
if.else.land.end_crit_edge to land.end: 8 1.000000e+00
land.rhs to land.end: 13 1.000000e+00
if.else to land.rhs: 21 6.250000e-01
0				8				0				0				0				0				0				0				0				0				0				0				0				0				0				
0				0				0				0				0				0				0				0				0				0				0				0				0				0				2147483647				
0				0				0				26				0				0				0				0				0				0				0				0				0				0				0				
0				0				0				0				0				0				43				0				0				0				0				0				0				0				0				
0				0				0				43				0				0				0				0				0				0				0				0				0				0				0				
0				0				26				0				0				0				0				43				0				0				0				0				0				0				0				
22				0				0				0				0				0				0				0				0				0				0				0				0				0				0				
0				0				0				0				0				0				0				0				22				22				0				0				0				0				0				
0				0				0				0				0				0				0				0				0				0				0				8				14				0				0				
0				0				0				0				22				0				0				0				0				0				0				0				0				0				0				
0				0				0				0				22				0				0				0				0				0				0				0				0				0				0				
0				0				0				0				0				0				0				0				0				0				9				0				0				0				0				
0				0				0				0				0				0				0				0				0				0				14				0				0				0				0				
0				0				0				0				0				2147483647				0				0				0				0				0				0				0				0				0				
0				0				0				0				0				0				0				0				0				0				0				0				0				0				0				
min cut from 13 to 14
if.else15 - if.else15.land.end21_crit_edge
insert into if.else15.land.end21_crit_edge.split
available
  %cmp13 = icmp sge i32 %8, %9
  %9 = load i32, i32* %val12, align 8
  %val12 = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 2
  %0 = load %struct.node*, %struct.node** %left, align 8
  %right = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 1
  %result.1 = phi i32 [ %result.0, %if.end ], [ 1, %entry.if.end7_crit_edge ]
  %left = getelementptr inbounds %struct.node, %struct.node* %p, i32 0, i32 0
  %tobool18 = icmp ne i32 %call17, 0
  %cmp8 = icmp ne %struct.node* %6, null
  %call17 = call i32 @Checktree(%struct.node* %10)
  %10 = load %struct.node*, %struct.node** %right16, align 8
  %6 = load %struct.node*, %struct.node** %right, align 8
  %8 = load i32, i32* %val11, align 8
  %val11 = getelementptr inbounds %struct.node, %struct.node* %7, i32 0, i32 2
  %cmp = icmp ne %struct.node* %0, null
  %7 = load %struct.node*, %struct.node** %right10, align 8
39 prepared
try i1 false
PLEASE submit a bug report to https://bugs.llvm.org/ and include the crash backtrace.
Stack dump:
0.	Program arguments: opt -o Treesort/Treesort.pre.bc -pgo-instr-use -pgo-test-profile-file=pgo.profdata -load ../build/SPGVNPRE/LLVMHW2.so -spgvnpre
1.	Running pass 'Function Pass Manager' on module '<stdin>'.
2.	Running pass 'SPeculation-based Global Value Numbering/Partial Redundancy Elimination' on function '@Checktree'
 #0 0x0000556be62a9e2c llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) /home/leozhu/llvm-project/llvm/lib/Support/Unix/Signals.inc:565:22
 #1 0x0000556be62a9ee7 PrintStackTraceSignalHandler(void*) /home/leozhu/llvm-project/llvm/lib/Support/Unix/Signals.inc:632:1
 #2 0x0000556be62a7b5d llvm::sys::RunSignalHandlers() /home/leozhu/llvm-project/llvm/lib/Support/Signals.cpp:71:20
 #3 0x0000556be62a9778 SignalHandler(int) /home/leozhu/llvm-project/llvm/lib/Support/Unix/Signals.inc:407:1
 #4 0x00007fc6a92373c0 __restore_rt (/lib/x86_64-linux-gnu/libpthread.so.0+0x153c0)
 #5 0x00007fc6a8c278e8 llvm::User::getNumOperands() const (../build/SPGVNPRE/LLVMHW2.so+0xb58e8)
 #6 0x00007fc6a8c21642 (anonymous namespace)::SPGVNPRE::runOnFunction(llvm::Function&) (../build/SPGVNPRE/LLVMHW2.so+0xaf642)
 #7 0x0000556be57064fa llvm::FPPassManager::runOnFunction(llvm::Function&) /home/leozhu/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:1435:20
 #8 0x0000556be57067c3 llvm::FPPassManager::runOnModule(llvm::Module&) /home/leozhu/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:1481:13
 #9 0x0000556be5706c35 (anonymous namespace)::MPPassManager::runOnModule(llvm::Module&) /home/leozhu/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:1550:20
#10 0x0000556be5701d30 llvm::legacy::PassManagerImpl::run(llvm::Module&) /home/leozhu/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:541:13
#11 0x0000556be570750b llvm::legacy::PassManager::run(llvm::Module&) /home/leozhu/llvm-project/llvm/lib/IR/LegacyPassManager.cpp:1678:1
#12 0x0000556be3066a88 main /home/leozhu/llvm-project/llvm/tools/opt/opt.cpp:997:15
#13 0x00007fc6a8cb70b3 __libc_start_main /build/glibc-eX1tMB/glibc-2.31/csu/../csu/libc-start.c:342:3
#14 0x0000556be302883e _start (/usr/local/bin/opt+0x1dca83e)
single.sh: line 50: 271557 Segmentation fault      (core dumped) opt -o ${1}/${1}.pre.bc -pgo-instr-use -pgo-test-profile-file=pgo.profdata -load ${PATH_MYPASS} ${NAME_MYPASS} < ${1}/${1}_reg.bc > /dev/null
single.sh: line 52: Treesort/Treesort.pre.bc: No such file or directory
Error: dot: can't open .Treesort.dot
opt: Treesort/Treesort.pre.bc: error: Could not open input file: No such file or directory
single.sh: line 66: Treesort/Treesort_final.bc: No such file or directory
Error: dot: can't open .Treesort.dot
