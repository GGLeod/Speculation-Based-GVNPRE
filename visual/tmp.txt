33333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333Writing '.licm.dot'...
Writing '.main.dot'...
licm begin
  %rem = srem i32 %i.0, 10
  %add2 = add nsw i32 %a, %b
  %inc = add nsw i32 %i.0, 1
  %add = add nsw i32 %a, %b
changed
for.inc
if.end
if.then
if.else
for.body
new
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %rem = srem i32 %i.0, 10
for.end
for.cond
new
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
entry
new
i32 0
changed
for.inc
new
  %inc = add nsw i32 %i.0, 1
if.end
new
  %inc = add nsw i32 %i.0, 1
  %add2 = add nsw i32 %a, %b
if.then
new
  %inc = add nsw i32 %i.0, 1
  %add2 = add nsw i32 %a, %b
if.else
new
  %inc = add nsw i32 %i.0, 1
  %add2 = add nsw i32 %a, %b
for.body
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %rem = srem i32 %i.0, 10
new
  %inc = add nsw i32 %i.0, 1
  %add2 = add nsw i32 %a, %b
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %rem = srem i32 %i.0, 10
for.cond
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
new
  %add2 = add nsw i32 %a, %b
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
entry
i32 0
new
  %add2 = add nsw i32 %a, %b
i32 0
changed
for.inc
  %inc = add nsw i32 %i.0, 1
new
  %add2 = add nsw i32 %a, %b
  %inc = add nsw i32 %i.0, 1
if.end
  %inc = add nsw i32 %i.0, 1
  %add2 = add nsw i32 %a, %b
if.then
  %inc = add nsw i32 %i.0, 1
  %add2 = add nsw i32 %a, %b
if.else
  %inc = add nsw i32 %i.0, 1
  %add2 = add nsw i32 %a, %b
for.body
  %inc = add nsw i32 %i.0, 1
  %add2 = add nsw i32 %a, %b
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %rem = srem i32 %i.0, 10
for.cond
  %add2 = add nsw i32 %a, %b
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
entry
  %add2 = add nsw i32 %a, %b
i32 0
changed
for.inc
  %add2 = add nsw i32 %a, %b
  %inc = add nsw i32 %i.0, 1
avaiableOut for each Basic Block 
Block: for.inc
1   %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
3   %cmp = icmp slt i32 %i.0, 100
5   %rem = srem i32 %i.0, 10
7   %cmp1 = icmp ne i32 %rem, 1
10   %add2 = add nsw i32 %a, %b
11   %call3 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i32 %add2)
12   %inc = add nsw i32 %i.0, 1
Block: for.end
1   %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
3   %cmp = icmp slt i32 %i.0, 100
Block: entry
Block: for.body
1   %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
3   %cmp = icmp slt i32 %i.0, 100
5   %rem = srem i32 %i.0, 10
7   %cmp1 = icmp ne i32 %rem, 1
Block: for.cond
1   %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
3   %cmp = icmp slt i32 %i.0, 100
Block: if.else
1   %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
3   %cmp = icmp slt i32 %i.0, 100
5   %rem = srem i32 %i.0, 10
7   %cmp1 = icmp ne i32 %rem, 1
10   %add = add nsw i32 %a, %b
13   %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i32 %add)
Block: if.then
1   %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
3   %cmp = icmp slt i32 %i.0, 100
5   %rem = srem i32 %i.0, 10
7   %cmp1 = icmp ne i32 %rem, 1
Block: if.end
1   %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
3   %cmp = icmp slt i32 %i.0, 100
5   %rem = srem i32 %i.0, 10
7   %cmp1 = icmp ne i32 %rem, 1
10   %add2 = add nsw i32 %a, %b
11   %call3 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i32 %add2)
anticipateIn for each Basic Block 
Block: for.inc
10   %add2 = add nsw i32 %a, %b
12   %inc = add nsw i32 %i.0, 1
Block: for.end
Block: entry
10   %add2 = add nsw i32 %a, %b
14 i32 0
Block: for.body
10   %add2 = add nsw i32 %a, %b
12   %inc = add nsw i32 %i.0, 1
1   %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
5   %rem = srem i32 %i.0, 10
Block: for.cond
10   %add2 = add nsw i32 %a, %b
1   %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
Block: if.else
10   %add2 = add nsw i32 %a, %b
12   %inc = add nsw i32 %i.0, 1
Block: if.then
10   %add2 = add nsw i32 %a, %b
12   %inc = add nsw i32 %i.0, 1
Block: if.end
10   %add2 = add nsw i32 %a, %b
12   %inc = add nsw i32 %i.0, 1
15
available out point of each value number0: 
1: if.end if.then if.else for.cond for.body for.end for.inc 
2: 
3: if.end if.then if.else for.cond for.body for.end for.inc 
4: 
5: if.end if.then if.else for.body for.inc 
6: 
7: if.end if.then if.else for.body for.inc 
8: 
9: 
10: if.end if.else for.inc 
11: if.end for.inc 
12: for.inc 
13: if.else 
14: 
antipate in point of each value number0: 
1: for.cond for.body 
2: 
3: 
4: 
5: for.body 
6: 
7: 
8: 
9: 
10: if.end if.then if.else for.cond for.body entry for.inc 
11: 
12: if.end if.then if.else for.body for.inc 
13: 
14: entry 
valunumber: 0
0				0				
0				0				
min cut from 0 to 1
essentail: entry for.cond
valunumber: 1
0 entry to 1 for.cond: 1 1.000000e+00
0				2				0				0				
0				0				0				2147483647				
2147483647				0				0				0				
0				0				0				0				
min cut from 2 to 3
entry - for.cond
valunumber: 2
0				0				
0				0				
min cut from 0 to 1
valunumber: 3
0				0				
0				0				
min cut from 0 to 1
valunumber: 4
0				0				
0				0				
min cut from 0 to 1
essentail: for.cond for.body
valunumber: 5
0 for.cond to 1 for.body: 101 9.900990e-01
0				101				0				0				
0				0				0				2147483647				
2147483647				0				0				0				
0				0				0				0				
min cut from 2 to 3
for.cond - for.body
valunumber: 6
0				0				
0				0				
min cut from 0 to 1
valunumber: 7
0				0				
0				0				
min cut from 0 to 1
valunumber: 8
0				0				
0				0				
min cut from 0 to 1
valunumber: 9
0				0				
0				0				
min cut from 0 to 1
essentail: if.then if.end
essentail: for.body if.then
essentail: for.body if.else
essentail: entry for.cond
essentail: for.cond for.body
valunumber: 10
0 if.then to 1 if.end: 90 1.000000e+00
2 for.body to 0 if.then: 100 9.000000e-01
2 for.body to 3 if.else: 100 1.000000e-01
4 entry to 5 for.cond: 1 1.000000e+00
5 for.cond to 2 for.body: 101 9.900990e-01
0				91				0				0				0				0				0				0				
0				0				0				0				0				0				0				2147483647				
90				0				0				11				0				0				0				0				
0				0				0				0				0				0				0				2147483647				
0				0				0				0				0				2				0				0				
0				0				101				0				0				0				0				0				
0				0				0				0				2147483647				0				0				0				
0				0				0				0				0				0				0				0				
min cut from 6 to 7
entry - for.cond
valunumber: 11
0				0				
0				0				
min cut from 0 to 1
essentail: if.else if.end
essentail: if.then if.end
essentail: for.body if.then
essentail: for.body if.else
essentail: for.cond for.body
essentail: if.end for.inc
valunumber: 12
0 if.else to 1 if.end: 10 1.000000e+00
2 if.then to 1 if.end: 90 1.000000e+00
3 for.body to 2 if.then: 100 9.000000e-01
3 for.body to 0 if.else: 100 1.000000e-01
4 for.cond to 3 for.body: 101 9.900990e-01
1 if.end to 5 for.inc: 100 1.000000e+00
0				11				0				0				0				0				0				0				
0				0				0				0				0				101				0				0				
0				91				0				0				0				0				0				0				
11				0				90				0				0				0				0				0				
0				0				0				101				0				0				0				0				
0				0				0				0				0				0				0				2147483647				
0				0				0				0				2147483647				0				0				0				
0				0				0				0				0				0				0				0				
min cut from 6 to 7
for.cond - for.body
valunumber: 13
0				0				
0				0				
min cut from 0 to 1
valunumber: 14
0				0				
0				0				
min cut from 0 to 1
insert into for.body.split
available
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 100
5 prepared
try   %rem = srem i32 %i.0, 10
12 prepared
try   %inc = add nsw i32 %i.0, 1

for.body.split:                                   ; preds = %for.cond
  %OptInsert_rem = srem i32 %i.0, 10
  %OptInsert_inc = add nsw i32 %i.0, 1
  br label %for.body

insert into entry.split
available
1 prepared
try   %i.0 = phi i32 [ 0, %entry.split ], [ %inc, %for.inc ]
10 prepared
try   %add2 = add nsw i32 %a, %b

entry.split:                                      ; preds = %entry
  %OptInsert_add2 = add nsw i32 %a, %b
  br label %for.cond

if.then has dominance frontier:
if.end 
if.else has dominance frontier:
if.end 
for.body.split has dominance frontier:
for.cond 
for.body has dominance frontier:
for.cond 
if.end has dominance frontier:
for.cond 
for.inc has dominance frontier:
for.cond 
10 in newValueSet
  %OptInsert_add2 = add nsw i32 %a, %b
10 in newDefined
  %OptInsert_add2 = add nsw i32 %a, %b
12 in newValueSet
  %OptInsert_inc = add nsw i32 %i.0, 1
12 in newDefined
  %OptInsert_inc = add nsw i32 %i.0, 1
5 in newValueSet
  %OptInsert_rem = srem i32 %i.0, 10
5 in newDefined
  %OptInsert_rem = srem i32 %i.0, 10
revNewValue
5:   %OptInsert_rem = srem i32 %i.0, 10
12:   %OptInsert_inc = add nsw i32 %i.0, 1
10:   %OptInsert_add2 = add nsw i32 %a, %b
rename: entry
  br label %entry.split
fill in phi

entry.split:                                      ; preds = %entry
  %OptInsert_add2 = add nsw i32 %a, %b
  br label %for.cond
rename: entry.split
  %OptInsert_add2 = add nsw i32 %a, %b
  br label %for.cond
fill in phi

for.cond:                                         ; preds = %for.inc, %entry.split
  %i.0 = phi i32 [ 0, %entry.split ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 100
  br i1 %cmp, label %for.body.split, label %for.end, !prof !32
  %inc = add nsw i32 %i.0, 1
rename: for.cond
  %i.0 = phi i32 [ 0, %entry.split ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 100
  %i.0 = phi i32 [ 0, %entry.split ], [ %inc, %for.inc ]
  br i1 %cmp, label %for.body.split, label %for.end, !prof !32
  %cmp = icmp slt i32 %i.0, 100
fill in phi

for.body.split:                                   ; preds = %for.cond
  %OptInsert_rem = srem i32 %i.0, 10
  %OptInsert_inc = add nsw i32 %i.0, 1
  br label %for.body

for.end:                                          ; preds = %for.cond
  ret void
rename: for.body.split
  %OptInsert_rem = srem i32 %i.0, 10
  %i.0 = phi i32 [ 0, %entry.split ], [ %inc, %for.inc ]
  %OptInsert_inc = add nsw i32 %i.0, 1
  %i.0 = phi i32 [ 0, %entry.split ], [ %inc, %for.inc ]
  br label %for.body
fill in phi

for.body:                                         ; preds = %for.body.split
  %rem = srem i32 %i.0, 10
  %cmp1 = icmp ne i32 %rem, 1
  br i1 %cmp1, label %if.then, label %if.else, !prof !33
rename: for.body
  %rem = srem i32 %i.0, 10
  %i.0 = phi i32 [ 0, %entry.split ], [ %inc, %for.inc ]
  %cmp1 = icmp ne i32 %rem, 1
  %rem = srem i32 %i.0, 10
  br i1 %cmp1, label %if.then, label %if.else, !prof !33
  %cmp1 = icmp ne i32 %OptInsert_rem, 1
fill in phi

if.then:                                          ; preds = %for.body
  br label %if.end

if.else:                                          ; preds = %for.body
  %add = add nsw i32 %a, %b
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i32 %add)
  br label %if.end
rename: if.then
  br label %if.end
fill in phi

if.end:                                           ; preds = %if.else, %if.then
  %add2 = add nsw i32 %a, %b
  %call3 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i32 %add2)
  br label %for.inc
rename: if.end
  %add2 = add nsw i32 %a, %b
  %call3 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i32 %add2)
  %add2 = add nsw i32 %a, %b
  br label %for.inc
fill in phi

for.inc:                                          ; preds = %if.end
  %inc = add nsw i32 %i.0, 1
  br label %for.cond, !llvm.loop !34
rename: for.inc
  %inc = add nsw i32 %i.0, 1
  %i.0 = phi i32 [ 0, %entry.split ], [ %inc, %for.inc ]
  br label %for.cond, !llvm.loop !34
fill in phi

for.cond:                                         ; preds = %for.inc, %entry.split
  %i.0 = phi i32 [ 0, %entry.split ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 100
  br i1 %cmp, label %for.body.split, label %for.end, !prof !32
  %inc = add nsw i32 %i.0, 1
rename: if.else
  %add = add nsw i32 %a, %b
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i32 %add)
  %add = add nsw i32 %a, %b
  br label %if.end
fill in phi

if.end:                                           ; preds = %if.else, %if.then
  %add2 = add nsw i32 %a, %b
  %call3 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i32 %OptInsert_add2)
  br label %for.inc
rename: for.end
  ret void
fill in phi

entry:
  br label %entry.split


entry.split:                                      ; preds = %entry
  %OptInsert_add2 = add nsw i32 %a, %b
  br label %for.cond


for.cond:                                         ; preds = %for.inc, %entry.split
  %i.0 = phi i32 [ 0, %entry.split ], [ %OptInsert_inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 100
  br i1 %cmp, label %for.body.split, label %for.end, !prof !32


for.body.split:                                   ; preds = %for.cond
  %OptInsert_rem = srem i32 %i.0, 10
  %OptInsert_inc = add nsw i32 %i.0, 1
  br label %for.body


for.body:                                         ; preds = %for.body.split
  %rem = srem i32 %i.0, 10
  %cmp1 = icmp ne i32 %OptInsert_rem, 1
  br i1 %cmp1, label %if.then, label %if.else, !prof !33


if.then:                                          ; preds = %for.body
  br label %if.end


if.else:                                          ; preds = %for.body
  %add = add nsw i32 %a, %b
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i32 %OptInsert_add2)
  br label %if.end


if.end:                                           ; preds = %if.else, %if.then
  %add2 = add nsw i32 %a, %b
  %call3 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i32 %OptInsert_add2)
  br label %for.inc


for.inc:                                          ; preds = %if.end
  %inc = add nsw i32 %i.0, 1
  br label %for.cond, !llvm.loop !34


for.end:                                          ; preds = %for.cond
  ret void

entry
  br label %entry.split
entry.split
  %OptInsert_add2 = add nsw i32 %a, %b
  br label %for.cond
for.cond
  %i.0 = phi i32 [ 0, %entry.split ], [ %OptInsert_inc, %for.inc ]
  %i.0 = phi i32 [ 0, %entry.split ], [ %OptInsert_inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 100
  br i1 %cmp, label %for.body.split, label %for.end, !prof !32
for.body.split
  %OptInsert_rem = srem i32 %i.0, 10
  %OptInsert_inc = add nsw i32 %i.0, 1
  br label %for.body
for.body
  %rem = srem i32 %i.0, 10
  %cmp1 = icmp ne i32 %OptInsert_rem, 1
  br i1 %cmp1, label %if.then, label %if.else, !prof !33
if.then
  br label %if.end
if.else
  %add = add nsw i32 %a, %b
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i32 %OptInsert_add2)
  br label %if.end
if.end
  %add2 = add nsw i32 %a, %b
  %call3 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i32 %OptInsert_add2)
  br label %for.inc
for.inc
  %inc = add nsw i32 %i.0, 1
  br label %for.cond, !llvm.loop !34
for.end
  ret void
main begin
changed
entry
avaiableOut for each Basic Block 
Block: entry
1   call void @licm(i32 1, i32 2)
anticipateIn for each Basic Block 
Block: entry
2
available out point of each value number0: 
1: entry 
antipate in point of each value number0: 
1: 
valunumber: 0
0				0				
0				0				
min cut from 0 to 1
valunumber: 1
0				0				
0				0				
min cut from 0 to 1
revNewValue
rename: entry
  call void @licm(i32 1, i32 2)
  ret i32 0
fill in phi

entry:
  call void @licm(i32 1, i32 2)
  ret i32 0

entry
  call void @licm(i32 1, i32 2)
  ret i32 0
Writing '.licm.dot'...
Writing '.main.dot'...
Writing '.licm.dot'...
Writing '.main.dot'...

entry:
  %0 = add nsw i32 %a, %b
  br label %for.cond

for.cond:                                         ; preds = %if.end, %entry
  %i.0 = phi i32 [ 0, %entry ], [ %OptInsert_inc, %if.end ]
  %cmp = icmp slt i32 %i.0, 100
  br i1 %cmp, label %for.body.split, label %for.end, !prof !32

for.body.split:                                   ; preds = %for.cond
  %OptInsert_rem = srem i32 %i.0, 10
  %OptInsert_inc = add nsw i32 %i.0, 1
  %1 = icmp ne i32 %OptInsert_rem, 1
  br i1 %1, label %if.then, label %if.else, !prof !33

if.then:                                          ; preds = %for.body.split
  br label %if.end

if.else:                                          ; preds = %for.body.split
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i32 %0)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %call3 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i32 %0)
  br label %for.cond, !llvm.loop !34

for.end:                                          ; preds = %for.cond
  ret void

entry:
  call void @licm(i32 1, i32 2)
  ret i32 0
Writing '.licm.dot'...
Writing '.main.dot'...
rm: cannot remove '.': Is a directory
rm: cannot remove '..': Is a directory
