9919619619610196-1196-1196-1196-1196-1196-1196-1196-1196196196-1196-1196-1196-1196-1196-1196-1196-1196-1196196196-1196-1196-1196-1196-1196-1196-1196-1196-1196196196-1196-1196-1196-1196-1196-1196-1196-1196-1196196196-1196-1196-1196-1196-1196-1196-1196-1196-1196196196-1196-1196-1196-1196-1196-1196-1196-1196-1196196196-1196-1196-1196-1196-1196-1196-1196-1196-1196196196-1196-1196-1196-1196-1196-1196-1196-1196-1196196196-1196-1196-1196-1196-1196-1196-1196-1196-1196196196-1196-1196-1196-1196-1196-1196-1196-1196Writing '.main.dot'...
begin
changed
for.inc
if.end
if.then
if.else
for.body
new
  %call = call i32 @getchar()
  %add = add nsw i32 %call, 1
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %rem = srem i32 %i.0, 10
for.end
for.cond
new
  %call = call i32 @getchar()
  %add = add nsw i32 %call, 1
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
entry
new
  %call = call i32 @getchar()
i32 0
changed
for.inc
new
  %call = call i32 @getchar()
  %add = add nsw i32 %call, 1
  %inc = add nsw i32 %i.0, 1
if.end
new
  %call = call i32 @getchar()
  %add = add nsw i32 %call, 1
  %inc = add nsw i32 %i.0, 1
  %call1 = call i32 @getchar()
if.then
new
  %call = call i32 @getchar()
  %add = add nsw i32 %call, 1
  %inc = add nsw i32 %i.0, 1
  %call1 = call i32 @getchar()
if.else
new
  %call = call i32 @getchar()
  %add = add nsw i32 %call, 1
  %inc = add nsw i32 %i.0, 1
  %call1 = call i32 @getchar()
  %add5 = add nsw i32 %add, %call1
for.body
  %call = call i32 @getchar()
  %add = add nsw i32 %call, 1
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %rem = srem i32 %i.0, 10
new
  %call = call i32 @getchar()
  %add = add nsw i32 %call, 1
  %inc = add nsw i32 %i.0, 1
  %call1 = call i32 @getchar()
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %rem = srem i32 %i.0, 10
for.cond
  %call = call i32 @getchar()
  %add = add nsw i32 %call, 1
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
new
  %call = call i32 @getchar()
  %add = add nsw i32 %call, 1
  %call1 = call i32 @getchar()
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
entry
  %call = call i32 @getchar()
i32 0
new
  %call = call i32 @getchar()
  %call1 = call i32 @getchar()
i32 0
changed
for.inc
  %call = call i32 @getchar()
  %add = add nsw i32 %call, 1
  %inc = add nsw i32 %i.0, 1
new
  %call = call i32 @getchar()
  %add = add nsw i32 %call, 1
  %call1 = call i32 @getchar()
  %inc = add nsw i32 %i.0, 1
if.end
  %call = call i32 @getchar()
  %add = add nsw i32 %call, 1
  %inc = add nsw i32 %i.0, 1
  %call1 = call i32 @getchar()
if.then
  %call = call i32 @getchar()
  %add = add nsw i32 %call, 1
  %inc = add nsw i32 %i.0, 1
  %call1 = call i32 @getchar()
if.else
  %call = call i32 @getchar()
  %add = add nsw i32 %call, 1
  %inc = add nsw i32 %i.0, 1
  %call1 = call i32 @getchar()
  %add5 = add nsw i32 %add, %call1
for.body
  %call = call i32 @getchar()
  %add = add nsw i32 %call, 1
  %inc = add nsw i32 %i.0, 1
  %call1 = call i32 @getchar()
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %rem = srem i32 %i.0, 10
for.cond
  %call = call i32 @getchar()
  %add = add nsw i32 %call, 1
  %call1 = call i32 @getchar()
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
entry
  %call = call i32 @getchar()
  %call1 = call i32 @getchar()
i32 0
changed
for.inc
  %call = call i32 @getchar()
  %add = add nsw i32 %call, 1
  %call1 = call i32 @getchar()
  %inc = add nsw i32 %i.0, 1
avaiableOut for each Basic Block 
Block: entry
1   %call = call i32 @getchar()
2   %call1 = call i32 @getchar()
Block: for.body
1   %call = call i32 @getchar()
2   %call1 = call i32 @getchar()
3   %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
5   %cmp = icmp slt i32 %i.0, 100
7   %add = add nsw i32 %call, 1
9   %rem = srem i32 %i.0, 10
10   %cmp2 = icmp ne i32 %rem, 1
Block: for.cond
1   %call = call i32 @getchar()
2   %call1 = call i32 @getchar()
3   %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
5   %cmp = icmp slt i32 %i.0, 100
Block: if.else
13   %add5 = add nsw i32 %add, %call1
2   %call1 = call i32 @getchar()
16   %call6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i32 %add5)
7   %add = add nsw i32 %call, 1
1   %call = call i32 @getchar()
5   %cmp = icmp slt i32 %i.0, 100
3   %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
10   %cmp2 = icmp ne i32 %rem, 1
9   %rem = srem i32 %i.0, 10
Block: if.then
11   %call3 = call i32 @getchar()
12   %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i32 %call3)
2   %call1 = call i32 @getchar()
7   %add = add nsw i32 %call, 1
1   %call = call i32 @getchar()
5   %cmp = icmp slt i32 %i.0, 100
3   %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
10   %cmp2 = icmp ne i32 %rem, 1
9   %rem = srem i32 %i.0, 10
Block: if.end
2   %call1 = call i32 @getchar()
7   %add = add nsw i32 %call, 1
1   %call = call i32 @getchar()
13   %add8 = add nsw i32 %add7, %call1
5   %cmp = icmp slt i32 %i.0, 100
14   %call9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i32 %add8)
3   %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
10   %cmp2 = icmp ne i32 %rem, 1
9   %rem = srem i32 %i.0, 10
Block: for.end
1   %call = call i32 @getchar()
2   %call1 = call i32 @getchar()
3   %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
5   %cmp = icmp slt i32 %i.0, 100
Block: for.inc
2   %call1 = call i32 @getchar()
7   %add = add nsw i32 %call, 1
1   %call = call i32 @getchar()
13   %add8 = add nsw i32 %add7, %call1
15   %inc = add nsw i32 %i.0, 1
5   %cmp = icmp slt i32 %i.0, 100
14   %call9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i32 %add8)
3   %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
10   %cmp2 = icmp ne i32 %rem, 1
9   %rem = srem i32 %i.0, 10
anticipateIn for each Basic Block 
Block: entry
1   %call = call i32 @getchar()
2   %call1 = call i32 @getchar()
17 i32 0
Block: for.body
1   %call = call i32 @getchar()
7   %add = add nsw i32 %call, 1
2   %call1 = call i32 @getchar()
15   %inc = add nsw i32 %i.0, 1
3   %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
9   %rem = srem i32 %i.0, 10
Block: for.cond
1   %call = call i32 @getchar()
7   %add = add nsw i32 %call, 1
2   %call1 = call i32 @getchar()
3   %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
Block: if.else
1   %call = call i32 @getchar()
7   %add = add nsw i32 %call, 1
2   %call1 = call i32 @getchar()
15   %inc = add nsw i32 %i.0, 1
13   %add5 = add nsw i32 %add, %call1
Block: if.then
1   %call = call i32 @getchar()
7   %add = add nsw i32 %call, 1
2   %call1 = call i32 @getchar()
15   %inc = add nsw i32 %i.0, 1
Block: if.end
1   %call = call i32 @getchar()
7   %add = add nsw i32 %call, 1
2   %call1 = call i32 @getchar()
15   %inc = add nsw i32 %i.0, 1
Block: for.end
Block: for.inc
1   %call = call i32 @getchar()
7   %add = add nsw i32 %call, 1
2   %call1 = call i32 @getchar()
15   %inc = add nsw i32 %i.0, 1
18
available out point of each value number0: 
1: for.inc for.end if.end if.then if.else for.cond for.body entry 
2: for.inc for.end if.end if.then if.else for.cond for.body entry 
3: for.inc for.end if.end if.then if.else for.cond for.body 
4: 
5: for.inc for.end if.end if.then if.else for.cond for.body 
6: 
7: for.inc if.end if.then if.else for.body 
8: 
9: for.inc if.end if.then if.else for.body 
10: for.inc if.end if.then if.else for.body 
11: if.then 
12: if.then 
13: for.inc if.end if.else 
14: for.inc if.end 
15: for.inc 
16: if.else 
17: 
antipate in point of each value number0: 
1: for.inc if.end if.then if.else for.cond for.body entry 
2: for.inc if.end if.then if.else for.cond for.body entry 
3: for.cond for.body 
4: 
5: 
6: 
7: for.inc if.end if.then if.else for.cond for.body 
8: 
9: for.body 
10: 
11: 
12: 
13: if.else 
14: 
15: for.inc if.end if.then if.else for.body 
16: 
17: entry 
valunumber: 0
0				0				
0				0				
min cut from 0 to 1
valunumber: 1
0				0				
0				0				
min cut from 0 to 1
valunumber: 2
0				0				
0				0				
min cut from 0 to 1
valunumber: 3
entry to for.cond: 8 1.000000e+00
0				9				0				0				
0				0				0				2147483647				
2147483647				0				0				0				
0				0				0				0				
min cut from 2 to 3
entry - for.cond
valunumber: 4
0				0				
0				0				
min cut from 0 to 1
valunumber: 5
0				0				
0				0				
min cut from 0 to 1
valunumber: 6
0				0				
0				0				
min cut from 0 to 1
valunumber: 7
entry to for.cond: 8 1.000000e+00
for.cond to for.body: 808 9.900990e-01
0				9				0				0				0				
0				0				801				0				0				
0				0				0				0				2147483647				
2147483647				0				0				0				0				
0				0				0				0				0				
min cut from 3 to 4
entry - for.cond
valunumber: 8
0				0				
0				0				
min cut from 0 to 1
valunumber: 9
for.cond to for.body: 808 9.900990e-01
0				801				0				0				
0				0				0				2147483647				
2147483647				0				0				0				
0				0				0				0				
min cut from 2 to 3
for.cond - for.body
valunumber: 10
0				0				
0				0				
min cut from 0 to 1
valunumber: 11
0				0				
0				0				
min cut from 0 to 1
valunumber: 12
0				0				
0				0				
min cut from 0 to 1
valunumber: 13
for.body to if.else: 800 1.000000e-01
0				81				0				0				
0				0				0				2147483647				
2147483647				0				0				0				
0				0				0				0				
min cut from 2 to 3
for.body - if.else
valunumber: 14
0				0				
0				0				
min cut from 0 to 1
valunumber: 15
if.end to for.inc: 800 1.000000e+00
if.else to if.end: 80 1.000000e+00
if.then to if.end: 720 1.000000e+00
for.body to if.then: 800 9.000000e-01
for.body to if.else: 800 1.000000e-01
for.cond to for.body: 808 9.900990e-01
0				801				0				0				0				0				0				0				
0				0				0				0				0				0				0				2147483647				
81				0				0				0				0				0				0				0				
721				0				0				0				0				0				0				0				
0				0				81				720				0				0				0				0				
0				0				0				0				801				0				0				0				
0				0				0				0				0				2147483647				0				0				
0				0				0				0				0				0				0				0				
min cut from 6 to 7
for.cond - for.body
valunumber: 16
0				0				
0				0				
min cut from 0 to 1
valunumber: 17
0				0				
0				0				
min cut from 0 to 1
insert into if.else.split
available
  %call = call i32 @getchar()
  %call1 = call i32 @getchar()
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 100
  %add = add nsw i32 %call, 1
  %rem = srem i32 %i.0, 10
  %cmp2 = icmp ne i32 %rem, 1
13 prepared
try   %add5 = add nsw i32 %add, %call1

if.else.split:                                    ; preds = %for.body
  %OptInsert_add5 = add nsw i32 %add, %call1
  br label %if.else

insert into for.body.split
available
  %call = call i32 @getchar()
  %call1 = call i32 @getchar()
  %i.0 = phi i32 [ 0, %entry ], [ %inc, %for.inc ]
  %cmp = icmp slt i32 %i.0, 100
9 prepared
try   %rem = srem i32 %i.0, 10
15 prepared
try   %inc = add nsw i32 %i.0, 1

for.body.split:                                   ; preds = %for.cond
  %OptInsert_rem = srem i32 %i.0, 10
  %OptInsert_inc = add nsw i32 %i.0, 1
  br label %for.body

insert into entry.split
available
  %call = call i32 @getchar()
  %call1 = call i32 @getchar()
3 prepared
try   %i.0 = phi i32 [ 0, %entry.split ], [ %inc, %for.inc ]
7 prepared
try   %add = add nsw i32 %call, 1

entry.split:                                      ; preds = %entry
  %OptInsert_add = add nsw i32 %call, 1
  br label %for.cond

if.then has dominance frontier:
if.end 
if.else.split has dominance frontier:
if.end 
if.else has dominance frontier:
if.end 
for.body has dominance frontier:
for.cond 
if.end has dominance frontier:
for.cond 
for.body.split has dominance frontier:
for.cond 
for.inc has dominance frontier:
for.cond 
7 in newValueSet
  %OptInsert_add = add nsw i32 %call, 1
  %nullLoad7 = load i32, i32* %nullalloc7, align 4
7 in newDefined
  %OptInsert_add = add nsw i32 %call, 1
  %nullLoad7 = load i32, i32* %nullalloc7, align 4

for.cond:                                         ; preds = %for.inc, %entry.split
  %i.0 = phi i32 [ 0, %entry.split ], [ %inc, %for.inc ]
  %NewPhi_OptInsert_inc = phi i32 
  %cmp = icmp slt i32 %i.0, 100
  br i1 %cmp, label %for.body.split, label %for.end, !prof !32
15 in newValueSet
  %OptInsert_inc = add nsw i32 %i.0, 1
  %nullLoad15 = load i32, i32* %nullalloc15, align 4
  %NewPhi_OptInsert_inc = phi i32 
15 in newDefined
  %OptInsert_inc = add nsw i32 %i.0, 1
  %nullLoad15 = load i32, i32* %nullalloc15, align 4
  %NewPhi_OptInsert_inc = phi i32 

for.cond:                                         ; preds = %for.inc, %entry.split
  %i.0 = phi i32 [ 0, %entry.split ], [ %inc, %for.inc ]
  %NewPhi_OptInsert_inc = phi i32 
  %NewPhi_OptInsert_rem = phi i32 
  %cmp = icmp slt i32 %i.0, 100
  br i1 %cmp, label %for.body.split, label %for.end, !prof !32
9 in newValueSet
  %OptInsert_rem = srem i32 %i.0, 10
  %nullLoad9 = load i32, i32* %nullalloc9, align 4
  %NewPhi_OptInsert_rem = phi i32 
9 in newDefined
  %OptInsert_rem = srem i32 %i.0, 10
  %nullLoad9 = load i32, i32* %nullalloc9, align 4
  %NewPhi_OptInsert_rem = phi i32 

if.end:                                           ; preds = %if.else, %if.then
  %NewPhi_OptInsert_add5 = phi i32 
  %add7 = add nsw i32 %call, 1
  %add8 = add nsw i32 %add7, %call1
  %call9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i32 %add8)
  br label %for.inc

for.cond:                                         ; preds = %for.inc, %entry.split
  %i.0 = phi i32 [ 0, %entry.split ], [ %inc, %for.inc ]
  %NewPhi_OptInsert_inc = phi i32 
  %NewPhi_OptInsert_rem = phi i32 
  %NewPhi_NewPhi_OptInsert_add5 = phi i32 
  %cmp = icmp slt i32 %i.0, 100
  br i1 %cmp, label %for.body.split, label %for.end, !prof !32
13 in newValueSet
  %OptInsert_add5 = add nsw i32 %add, %call1
  %nullLoad13 = load i32, i32* %nullalloc13, align 4
  %NewPhi_OptInsert_add5 = phi i32 
  %NewPhi_NewPhi_OptInsert_add5 = phi i32 
13 in newDefined
  %OptInsert_add5 = add nsw i32 %add, %call1
  %nullLoad13 = load i32, i32* %nullalloc13, align 4
  %NewPhi_OptInsert_add5 = phi i32 
  %NewPhi_NewPhi_OptInsert_add5 = phi i32 
revNewValue
13:   %OptInsert_add5 = add nsw i32 %add, %call1
9:   %NewPhi_OptInsert_rem = phi i32 
13:   %NewPhi_OptInsert_add5 = phi i32 
9:   %OptInsert_rem = srem i32 %i.0, 10
15:   %NewPhi_OptInsert_inc = phi i32 
15:   %nullLoad15 = load i32, i32* %nullalloc15, align 4
13:   %NewPhi_NewPhi_OptInsert_add5 = phi i32 
9:   %nullLoad9 = load i32, i32* %nullalloc9, align 4
15:   %OptInsert_inc = add nsw i32 %i.0, 1
7:   %nullLoad7 = load i32, i32* %nullalloc7, align 4
13:   %nullLoad13 = load i32, i32* %nullalloc13, align 4
7:   %OptInsert_add = add nsw i32 %call, 1
rename: entry
  %call = call i32 @getchar()
  %call1 = call i32 @getchar()
  %nullalloc7 = alloca i32, align 4
  %nullLoad7 = load i32, i32* %nullalloc7, align 4
  %nullalloc7 = alloca i32, align 4
  %nullalloc15 = alloca i32, align 4
  %nullLoad15 = load i32, i32* %nullalloc15, align 4
  %nullalloc15 = alloca i32, align 4
  %nullalloc9 = alloca i32, align 4
  %nullLoad9 = load i32, i32* %nullalloc9, align 4
  %nullalloc9 = alloca i32, align 4
  %nullalloc13 = alloca i32, align 4
  %nullLoad13 = load i32, i32* %nullalloc13, align 4
  %nullalloc13 = alloca i32, align 4
  br label %entry.split
fill in phi

entry.split:                                      ; preds = %entry
  %OptInsert_add = add nsw i32 %call, 1
  br label %for.cond
rename: entry.split
  %OptInsert_add = add nsw i32 %call, 1
  %call = call i32 @getchar()
  br label %for.cond
fill in phi

for.cond:                                         ; preds = %for.inc, %entry.split
  %i.0 = phi i32 [ 0, %entry.split ], [ %inc, %for.inc ]
  %NewPhi_OptInsert_inc = phi i32 
  %NewPhi_OptInsert_rem = phi i32 
  %NewPhi_NewPhi_OptInsert_add5 = phi i32 
  %cmp = icmp slt i32 %i.0, 100
  br i1 %cmp, label %for.body.split, label %for.end, !prof !32
  %NewPhi_OptInsert_inc = phi i32 [ %nullLoad15, %entry.split ]
  %NewPhi_OptInsert_rem = phi i32 [ %nullLoad9, %entry.split ]
  %NewPhi_NewPhi_OptInsert_add5 = phi i32 [ %nullLoad13, %entry.split ]
rename: for.cond
  %i.0 = phi i32 [ 0, %entry.split ], [ %inc, %for.inc ]
  %NewPhi_OptInsert_inc = phi i32 [ %nullLoad15, %entry.split ]
  %NewPhi_OptInsert_rem = phi i32 [ %nullLoad9, %entry.split ]
  %NewPhi_NewPhi_OptInsert_add5 = phi i32 [ %nullLoad13, %entry.split ]
  %cmp = icmp slt i32 %i.0, 100
  %i.0 = phi i32 [ 0, %entry.split ], [ %inc, %for.inc ]
  br i1 %cmp, label %for.body.split, label %for.end, !prof !32
  %cmp = icmp slt i32 %i.0, 100
fill in phi

for.body.split:                                   ; preds = %for.cond
  %OptInsert_rem = srem i32 %i.0, 10
  %OptInsert_inc = add nsw i32 %i.0, 1
  br label %for.body

for.end:                                          ; preds = %for.cond
  ret i32 0
rename: for.body.split
  %OptInsert_rem = srem i32 %i.0, 10
  %i.0 = phi i32 [ 0, %entry.split ], [ %inc, %for.inc ]
  %OptInsert_inc = add nsw i32 %i.0, 1
  %i.0 = phi i32 [ 0, %entry.split ], [ %inc, %for.inc ]
  br label %for.body
fill in phi

for.body:                                         ; preds = %for.body.split
  %add = add nsw i32 %call, 1
  %rem = srem i32 %i.0, 10
  %cmp2 = icmp ne i32 %rem, 1
  br i1 %cmp2, label %if.then, label %if.else.split, !prof !33
rename: for.body
  %add = add nsw i32 %call, 1
  %call = call i32 @getchar()
  %rem = srem i32 %i.0, 10
  %i.0 = phi i32 [ 0, %entry.split ], [ %inc, %for.inc ]
  %cmp2 = icmp ne i32 %rem, 1
  %rem = srem i32 %i.0, 10
  br i1 %cmp2, label %if.then, label %if.else.split, !prof !33
  %cmp2 = icmp ne i32 %OptInsert_rem, 1
fill in phi

if.then:                                          ; preds = %for.body
  %call3 = call i32 @getchar()
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i32 %call3)
  br label %if.end

if.else.split:                                    ; preds = %for.body
  %OptInsert_add5 = add nsw i32 %add, %call1
  br label %if.else
rename: if.then
  %call3 = call i32 @getchar()
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i32 %call3)
  %call3 = call i32 @getchar()
  br label %if.end
fill in phi

if.end:                                           ; preds = %if.else, %if.then
  %NewPhi_OptInsert_add5 = phi i32 
  %add7 = add nsw i32 %call, 1
  %add8 = add nsw i32 %add7, %call1
  %call9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i32 %add8)
  br label %for.inc
  %NewPhi_OptInsert_add5 = phi i32 [ %NewPhi_NewPhi_OptInsert_add5, %if.then ]
rename: if.end
  %NewPhi_OptInsert_add5 = phi i32 [ %NewPhi_NewPhi_OptInsert_add5, %if.then ]
  %add7 = add nsw i32 %call, 1
  %call = call i32 @getchar()
  %add8 = add nsw i32 %add7, %call1
  %add7 = add nsw i32 %call, 1
  %call1 = call i32 @getchar()
  %call9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i32 %add8)
  %add8 = add nsw i32 %OptInsert_add, %call1
  br label %for.inc
fill in phi

for.inc:                                          ; preds = %if.end
  %inc = add nsw i32 %i.0, 1
  br label %for.cond, !llvm.loop !34
rename: for.inc
  %inc = add nsw i32 %i.0, 1
  %i.0 = phi i32 [ 0, %entry.split ], [ %inc, %for.inc ]
  br label %for.cond, !llvm.loop !34
fill in phi

for.cond:                                         ; preds = %for.inc, %entry.split
  %i.0 = phi i32 [ 0, %entry.split ], [ %inc, %for.inc ]
  %NewPhi_OptInsert_inc = phi i32 [ %nullLoad15, %entry.split ]
  %NewPhi_OptInsert_rem = phi i32 [ %nullLoad9, %entry.split ]
  %NewPhi_NewPhi_OptInsert_add5 = phi i32 [ %nullLoad13, %entry.split ]
  %cmp = icmp slt i32 %i.0, 100
  br i1 %cmp, label %for.body.split, label %for.end, !prof !32
  %NewPhi_OptInsert_inc = phi i32 [ %nullLoad15, %entry.split ], [ %OptInsert_inc, %for.inc ]
  %NewPhi_OptInsert_rem = phi i32 [ %nullLoad9, %entry.split ], [ %OptInsert_rem, %for.inc ]
  %NewPhi_NewPhi_OptInsert_add5 = phi i32 [ %nullLoad13, %entry.split ], [ %NewPhi_OptInsert_add5, %for.inc ]
rename: if.else.split
  %OptInsert_add5 = add nsw i32 %add, %call1
  %add = add nsw i32 %call, 1
  %call1 = call i32 @getchar()
  br label %if.else
fill in phi

if.else:                                          ; preds = %if.else.split
  %add5 = add nsw i32 %add, %call1
  %call6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i32 %add5)
  br label %if.end
rename: if.else
  %add5 = add nsw i32 %add, %call1
  %add = add nsw i32 %call, 1
  %call1 = call i32 @getchar()
  %call6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i32 %add5)
  %add5 = add nsw i32 %OptInsert_add, %call1
  br label %if.end
fill in phi

if.end:                                           ; preds = %if.else, %if.then
  %NewPhi_OptInsert_add5 = phi i32 [ %NewPhi_NewPhi_OptInsert_add5, %if.then ]
  %add7 = add nsw i32 %call, 1
  %add8 = add nsw i32 %OptInsert_add, %call1
  %call9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i32 %NewPhi_OptInsert_add5)
  br label %for.inc
  %NewPhi_OptInsert_add5 = phi i32 [ %NewPhi_NewPhi_OptInsert_add5, %if.then ], [ %OptInsert_add5, %if.else ]
rename: for.end
  ret i32 0
fill in phi

entry:
  %call = call i32 @getchar()
  %call1 = call i32 @getchar()
  %nullalloc7 = alloca i32, align 4
  %nullLoad7 = load i32, i32* %nullalloc7, align 4
  %nullalloc15 = alloca i32, align 4
  %nullLoad15 = load i32, i32* %nullalloc15, align 4
  %nullalloc9 = alloca i32, align 4
  %nullLoad9 = load i32, i32* %nullalloc9, align 4
  %nullalloc13 = alloca i32, align 4
  %nullLoad13 = load i32, i32* %nullalloc13, align 4
  br label %entry.split


entry.split:                                      ; preds = %entry
  %OptInsert_add = add nsw i32 %call, 1
  br label %for.cond


for.cond:                                         ; preds = %for.inc, %entry.split
  %i.0 = phi i32 [ 0, %entry.split ], [ %inc, %for.inc ]
  %NewPhi_OptInsert_inc = phi i32 [ %nullLoad15, %entry.split ], [ %OptInsert_inc, %for.inc ]
  %NewPhi_OptInsert_rem = phi i32 [ %nullLoad9, %entry.split ], [ %OptInsert_rem, %for.inc ]
  %NewPhi_NewPhi_OptInsert_add5 = phi i32 [ %nullLoad13, %entry.split ], [ %NewPhi_OptInsert_add5, %for.inc ]
  %cmp = icmp slt i32 %i.0, 100
  br i1 %cmp, label %for.body.split, label %for.end, !prof !32


for.body.split:                                   ; preds = %for.cond
  %OptInsert_rem = srem i32 %i.0, 10
  %OptInsert_inc = add nsw i32 %i.0, 1
  br label %for.body


for.body:                                         ; preds = %for.body.split
  %add = add nsw i32 %call, 1
  %rem = srem i32 %i.0, 10
  %cmp2 = icmp ne i32 %OptInsert_rem, 1
  br i1 %cmp2, label %if.then, label %if.else.split, !prof !33


if.then:                                          ; preds = %for.body
  %call3 = call i32 @getchar()
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i32 %call3)
  br label %if.end


if.else.split:                                    ; preds = %for.body
  %OptInsert_add5 = add nsw i32 %OptInsert_add, %call1
  br label %if.else


if.else:                                          ; preds = %if.else.split
  %add5 = add nsw i32 %OptInsert_add, %call1
  %call6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i32 %OptInsert_add5)
  br label %if.end


if.end:                                           ; preds = %if.else, %if.then
  %NewPhi_OptInsert_add5 = phi i32 [ %NewPhi_NewPhi_OptInsert_add5, %if.then ], [ %OptInsert_add5, %if.else ]
  %add7 = add nsw i32 %call, 1
  %add8 = add nsw i32 %OptInsert_add, %call1
  %call9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i32 %NewPhi_OptInsert_add5)
  br label %for.inc


for.inc:                                          ; preds = %if.end
  %inc = add nsw i32 %i.0, 1
  br label %for.cond, !llvm.loop !34


for.end:                                          ; preds = %for.cond
  ret i32 0

entry
  %call = call i32 @getchar()
  %call1 = call i32 @getchar()
  %nullalloc7 = alloca i32, align 4
  %nullLoad7 = load i32, i32* %nullalloc7, align 4
  %nullalloc15 = alloca i32, align 4
  %nullLoad15 = load i32, i32* %nullalloc15, align 4
  %nullalloc9 = alloca i32, align 4
  %nullLoad9 = load i32, i32* %nullalloc9, align 4
  %nullalloc13 = alloca i32, align 4
  %nullLoad13 = load i32, i32* %nullalloc13, align 4
  br label %entry.split
entry.split
  %OptInsert_add = add nsw i32 %call, 1
  br label %for.cond
for.cond
  %i.0 = phi i32 [ 0, %entry.split ], [ %inc, %for.inc ]
  %i.0 = phi i32 [ 0, %entry.split ], [ %inc, %for.inc ]
  %NewPhi_OptInsert_inc = phi i32 [ %nullLoad15, %entry.split ], [ %OptInsert_inc, %for.inc ]
  %NewPhi_OptInsert_inc = phi i32 [ %nullLoad15, %entry.split ], [ %OptInsert_inc, %for.inc ]
  %NewPhi_OptInsert_rem = phi i32 [ %nullLoad9, %entry.split ], [ %OptInsert_rem, %for.inc ]
  %NewPhi_OptInsert_rem = phi i32 [ %nullLoad9, %entry.split ], [ %OptInsert_rem, %for.inc ]
  %NewPhi_NewPhi_OptInsert_add5 = phi i32 [ %nullLoad13, %entry.split ], [ %NewPhi_OptInsert_add5, %for.inc ]
  %NewPhi_NewPhi_OptInsert_add5 = phi i32 [ %nullLoad13, %entry.split ], [ %NewPhi_OptInsert_add5, %for.inc ]
  %cmp = icmp slt i32 %i.0, 100
  br i1 %cmp, label %for.body.split, label %for.end, !prof !32
for.body.split
  %OptInsert_rem = srem i32 %i.0, 10
  %OptInsert_inc = add nsw i32 %i.0, 1
  br label %for.body
for.body
  %add = add nsw i32 %call, 1
  %rem = srem i32 %i.0, 10
  %cmp2 = icmp ne i32 %OptInsert_rem, 1
  br i1 %cmp2, label %if.then, label %if.else.split, !prof !33
if.then
  %call3 = call i32 @getchar()
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i32 %call3)
  br label %if.end
if.else.split
  %OptInsert_add5 = add nsw i32 %OptInsert_add, %call1
  br label %if.else
if.else
  %add5 = add nsw i32 %OptInsert_add, %call1
  %call6 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i32 %OptInsert_add5)
  br label %if.end
if.end
  %NewPhi_OptInsert_add5 = phi i32 [ %NewPhi_NewPhi_OptInsert_add5, %if.then ], [ %OptInsert_add5, %if.else ]
  %NewPhi_OptInsert_add5 = phi i32 [ %NewPhi_NewPhi_OptInsert_add5, %if.then ], [ %OptInsert_add5, %if.else ]
  %add7 = add nsw i32 %call, 1
  %add8 = add nsw i32 %OptInsert_add, %call1
  %call9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i64 0, i64 0), i32 %NewPhi_OptInsert_add5)
  br label %for.inc
for.inc
  %inc = add nsw i32 %i.0, 1
  br label %for.cond, !llvm.loop !34
for.end
  ret i32 0
Writing '.main.dot'...
99-136349233619619610196-1196-1196-1196-1196-1196-1196-1196-1196196196-1196-1196-1196-1196-1196-1196-1196-1196-1196196196-1196-1196-1196-1196-1196-1196-1196-1196-1196196196-1196-1196-1196-1196-1196-1196-1196-1196-1196196196-1196-1196-1196-1196-1196-1196-1196-1196-1196196196-1196-1196-1196-1196-1196-1196-1196-1196-1196196196-1196-1196-1196-1196-1196-1196-1196-1196-1196196196-1196-1196-1196-1196-1196-1196-1196-1196-1196196196-1196-1196-1196-1196-1196-1196-1196-1196-1196196196-1196-1196-1196-1196-1196-1196-1196-1196Writing '.main.dot'...
99019619610196-1196-1196-1196-1196-1196-1196-1196-1196196196-1196-1196-1196-1196-1196-1196-1196-1196-1196196196-1196-1196-1196-1196-1196-1196-1196-1196-1196196196-1196-1196-1196-1196-1196-1196-1196-1196-1196196196-1196-1196-1196-1196-1196-1196-1196-1196-1196196196-1196-1196-1196-1196-1196-1196-1196-1196-1196196196-1196-1196-1196-1196-1196-1196-1196-1196-1196196196-1196-1196-1196-1196-1196-1196-1196-1196-1196196196-1196-1196-1196-1196-1196-1196-1196-1196-1196196196-1196-1196-1196-1196-1196-1196-1196-1196